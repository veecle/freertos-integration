/* automatically generated by rust-bindgen 0.72.1 */

pub const _STDINT_H: u8 = 1;
pub const _FEATURES_H: u8 = 1;
pub const _DEFAULT_SOURCE: u8 = 1;
pub const __GLIBC_USE_ISOC2X: u8 = 0;
pub const __USE_ISOC11: u8 = 1;
pub const __USE_ISOC99: u8 = 1;
pub const __USE_ISOC95: u8 = 1;
pub const __USE_POSIX_IMPLICITLY: u8 = 1;
pub const _POSIX_SOURCE: u8 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u8 = 1;
pub const __USE_POSIX2: u8 = 1;
pub const __USE_POSIX199309: u8 = 1;
pub const __USE_POSIX199506: u8 = 1;
pub const __USE_XOPEN2K: u8 = 1;
pub const __USE_XOPEN2K8: u8 = 1;
pub const _ATFILE_SOURCE: u8 = 1;
pub const __WORDSIZE: u8 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u8 = 1;
pub const __SYSCALL_WORDSIZE: u8 = 64;
pub const __TIMESIZE: u8 = 64;
pub const __USE_MISC: u8 = 1;
pub const __USE_ATFILE: u8 = 1;
pub const __USE_FORTIFY_LEVEL: u8 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u8 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u8 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u8 = 0;
pub const _STDC_PREDEF_H: u8 = 1;
pub const __STDC_IEC_559__: u8 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u8 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u8 = 6;
pub const __GLIBC__: u8 = 2;
pub const __GLIBC_MINOR__: u8 = 39;
pub const _SYS_CDEFS_H: u8 = 1;
pub const __glibc_c99_flexarr_available: u8 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u8 = 0;
pub const __HAVE_GENERIC_SELECTION: u8 = 1;
pub const __GLIBC_USE_LIB_EXT2: u8 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u8 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u8 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u8 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u8 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u8 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u8 = 0;
pub const _BITS_TYPES_H: u8 = 1;
pub const _BITS_TYPESIZES_H: u8 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u8 = 1;
pub const __INO_T_MATCHES_INO64_T: u8 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u8 = 1;
pub const __STATFS_MATCHES_STATFS64: u8 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u8 = 1;
pub const __FD_SETSIZE: u16 = 1024;
pub const _BITS_TIME64_H: u8 = 1;
pub const _BITS_WCHAR_H: u8 = 1;
pub const _BITS_STDINT_INTN_H: u8 = 1;
pub const _BITS_STDINT_UINTN_H: u8 = 1;
pub const _BITS_STDINT_LEAST_H: u8 = 1;
pub const INT8_MIN: i8 = -128;
pub const INT16_MIN: i16 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u8 = 127;
pub const INT16_MAX: u16 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u8 = 255;
pub const UINT16_MAX: u16 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i8 = -128;
pub const INT_LEAST16_MIN: i16 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u8 = 127;
pub const INT_LEAST16_MAX: u16 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u8 = 255;
pub const UINT_LEAST16_MAX: u16 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i8 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u8 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u8 = 255;
pub const UINT_FAST16_MAX: i8 = -1;
pub const UINT_FAST32_MAX: i8 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i8 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i8 = -1;
pub const WINT_MIN: u8 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TICK_TYPE_WIDTH_16_BITS: u8 = 0;
pub const TICK_TYPE_WIDTH_32_BITS: u8 = 1;
pub const TICK_TYPE_WIDTH_64_BITS: u8 = 2;
pub const configUSE_PREEMPTION: u8 = 1;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u8 = 0;
pub const configUSE_IDLE_HOOK: u8 = 0;
pub const configUSE_TICK_HOOK: u8 = 0;
pub const configTICK_RATE_HZ: u16 = 1000;
pub const configTOTAL_HEAP_SIZE: u32 = 262144000;
pub const configMAX_TASK_NAME_LEN: u8 = 12;
pub const configUSE_TRACE_FACILITY: u8 = 1;
pub const configUSE_16_BIT_TICKS: u8 = 0;
pub const configIDLE_SHOULD_YIELD: u8 = 1;
pub const configUSE_MUTEXES: u8 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u8 = 0;
pub const configUSE_RECURSIVE_MUTEXES: u8 = 1;
pub const configQUEUE_REGISTRY_SIZE: u8 = 20;
pub const configUSE_MALLOC_FAILED_HOOK: u8 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u8 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u8 = 1;
pub const configUSE_QUEUE_SETS: u8 = 1;
pub const configUSE_TASK_NOTIFICATIONS: u8 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u8 = 1;
pub const configUSE_TIMERS: u8 = 1;
pub const configTIMER_QUEUE_LENGTH: u8 = 20;
pub const configMAX_PRIORITIES: u8 = 7;
pub const configGENERATE_RUN_TIME_STATS: u8 = 1;
pub const configUSE_CO_ROUTINES: u8 = 1;
pub const configMAX_CO_ROUTINE_PRIORITIES: u8 = 2;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u8 = 1;
pub const INCLUDE_vTaskPrioritySet: u8 = 1;
pub const INCLUDE_uxTaskPriorityGet: u8 = 1;
pub const INCLUDE_vTaskDelete: u8 = 0;
pub const INCLUDE_vTaskCleanUpResources: u8 = 0;
pub const INCLUDE_vTaskSuspend: u8 = 1;
pub const INCLUDE_vTaskDelayUntil: u8 = 1;
pub const INCLUDE_vTaskDelay: u8 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u8 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u8 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u8 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u8 = 1;
pub const INCLUDE_pcTaskGetTaskName: u8 = 1;
pub const INCLUDE_eTaskGetState: u8 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u8 = 1;
pub const INCLUDE_xTimerPendFunctionCall: u8 = 1;
pub const configTICK_TYPE_WIDTH_IN_BITS: u8 = 1;
pub const configUSE_MPU_WRAPPERS_V1: u8 = 0;
pub const configENABLE_ACCESS_CONTROL_LIST: u8 = 0;
pub const configNUMBER_OF_CORES: u8 = 1;
pub const configASSERT_DEFINED: u8 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i8 = -1;
pub const errQUEUE_BLOCKED: i8 = -4;
pub const errQUEUE_YIELD: i8 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u8 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u8 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u8 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u8 = 4;
pub const pdFREERTOS_ERRNO_EIO: u8 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u8 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u8 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u8 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u8 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u8 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u8 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u8 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u8 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u8 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u8 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u8 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u8 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u8 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u8 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u8 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u8 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u8 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u8 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u8 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u8 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u8 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u8 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u8 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u8 = 95;
pub const pdFREERTOS_ERRNO_EAFNOSUPPORT: u8 = 97;
pub const pdFREERTOS_ERRNO_ENOBUFS: u8 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u8 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u8 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u8 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u8 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u8 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u8 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u8 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u8 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u8 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u8 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u8 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u8 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u8 = 1;
pub const pdLITTLE_ENDIAN: u8 = 0;
pub const pdBIG_ENDIAN: u8 = 1;
pub const _LIBC_LIMITS_H_: u8 = 1;
pub const MB_LEN_MAX: u8 = 16;
pub const _BITS_POSIX1_LIM_H: u8 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u8 = 2;
pub const _POSIX_AIO_MAX: u8 = 1;
pub const _POSIX_ARG_MAX: u16 = 4096;
pub const _POSIX_CHILD_MAX: u8 = 25;
pub const _POSIX_DELAYTIMER_MAX: u8 = 32;
pub const _POSIX_HOST_NAME_MAX: u8 = 255;
pub const _POSIX_LINK_MAX: u8 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u8 = 9;
pub const _POSIX_MAX_CANON: u8 = 255;
pub const _POSIX_MAX_INPUT: u8 = 255;
pub const _POSIX_MQ_OPEN_MAX: u8 = 8;
pub const _POSIX_MQ_PRIO_MAX: u8 = 32;
pub const _POSIX_NAME_MAX: u8 = 14;
pub const _POSIX_NGROUPS_MAX: u8 = 8;
pub const _POSIX_OPEN_MAX: u8 = 20;
pub const _POSIX_PATH_MAX: u16 = 256;
pub const _POSIX_PIPE_BUF: u16 = 512;
pub const _POSIX_RE_DUP_MAX: u8 = 255;
pub const _POSIX_RTSIG_MAX: u8 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u16 = 256;
pub const _POSIX_SEM_VALUE_MAX: u16 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u8 = 32;
pub const _POSIX_SSIZE_MAX: u16 = 32767;
pub const _POSIX_STREAM_MAX: u8 = 8;
pub const _POSIX_SYMLINK_MAX: u8 = 255;
pub const _POSIX_SYMLOOP_MAX: u8 = 8;
pub const _POSIX_TIMER_MAX: u8 = 32;
pub const _POSIX_TTY_NAME_MAX: u8 = 9;
pub const _POSIX_TZNAME_MAX: u8 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u16 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u8 = 127;
pub const MAX_CANON: u8 = 255;
pub const MAX_INPUT: u8 = 255;
pub const NAME_MAX: u8 = 255;
pub const PATH_MAX: u16 = 4096;
pub const PIPE_BUF: u16 = 4096;
pub const XATTR_NAME_MAX: u8 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u8 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u8 = 128;
pub const PTHREAD_KEYS_MAX: u16 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u8 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u8 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u8 = 64;
pub const AIO_PRIO_DELTA_MAX: u8 = 20;
pub const PTHREAD_STACK_MIN: u16 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u8 = 32;
pub const LOGIN_NAME_MAX: u16 = 256;
pub const HOST_NAME_MAX: u8 = 64;
pub const MQ_PRIO_MAX: u16 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u8 = 1;
pub const _POSIX2_BC_BASE_MAX: u8 = 99;
pub const _POSIX2_BC_DIM_MAX: u16 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u8 = 99;
pub const _POSIX2_BC_STRING_MAX: u16 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u8 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u8 = 32;
pub const _POSIX2_LINE_MAX: u16 = 2048;
pub const _POSIX2_RE_DUP_MAX: u8 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u8 = 14;
pub const BC_BASE_MAX: u8 = 99;
pub const BC_DIM_MAX: u16 = 2048;
pub const BC_SCALE_MAX: u8 = 99;
pub const BC_STRING_MAX: u16 = 1000;
pub const COLL_WEIGHTS_MAX: u8 = 255;
pub const EXPR_NEST_MAX: u8 = 32;
pub const LINE_MAX: u16 = 2048;
pub const CHARCLASS_NAME_MAX: u16 = 2048;
pub const RE_DUP_MAX: u16 = 32767;
pub const portTICK_TYPE_IS_ATOMIC: u8 = 1;
pub const portSTACK_GROWTH: i8 = -1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u8 = 1;
pub const portBYTE_ALIGNMENT: u8 = 8;
pub const portBYTE_ALIGNMENT_MASK: u8 = 7;
pub const portUSING_MPU_WRAPPERS: u8 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u8 = 1;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u8 = 0;
pub const configUSE_NEWLIB_REENTRANT: u8 = 0;
pub const configUSE_PICOLIBC_TLS: u8 = 0;
pub const configUSE_C_RUNTIME_TLS_SUPPORT: u8 = 0;
pub const INCLUDE_xTaskDelayUntil: u8 = 1;
pub const INCLUDE_xTaskAbortDelay: u8 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u8 = 0;
pub const INCLUDE_xTaskGetHandle: u8 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u8 = 0;
pub const INCLUDE_xTaskResumeFromISR: u8 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u8 = 1;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u8 = 0;
pub const configUSE_EVENT_GROUPS: u8 = 1;
pub const configUSE_STREAM_BUFFERS: u8 = 1;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u8 = 0;
pub const configUSE_TASK_PREEMPTION_DISABLE: u8 = 0;
pub const configUSE_ALTERNATIVE_API: u8 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u8 = 0;
pub const configPRECONDITION_DEFINED: u8 = 0;
pub const configCHECK_HANDLER_INSTALLATION: u8 = 1;
pub const configRUN_MULTIPLE_PRIORITIES: u8 = 0;
pub const configUSE_CORE_AFFINITY: u8 = 0;
pub const configUSE_PASSIVE_IDLE_HOOK: u8 = 0;
pub const portHAS_NESTED_INTERRUPTS: u8 = 1;
pub const configUSE_MINI_LIST_ITEM: u8 = 1;
pub const configRECORD_STACK_HIGH_ADDRESS: u8 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u8 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u8 = 2;
pub const configUSE_TICKLESS_IDLE: u8 = 0;
pub const configUSE_TIME_SLICING: u8 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u8 = 0;
pub const configAPPLICATION_ALLOCATED_HEAP: u8 = 0;
pub const configENABLE_HEAP_PROTECTOR: u8 = 0;
pub const configUSE_POSIX_ERRNO: u8 = 0;
pub const configUSE_SB_COMPLETED_CALLBACK: u8 = 0;
pub const configSUPPORT_STATIC_ALLOCATION: u8 = 0;
pub const configKERNEL_PROVIDED_STATIC_MEMORY: u8 = 0;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u8 = 1;
pub const configSTATS_BUFFER_MAX_LENGTH: u16 = 65535;
pub const configINITIAL_TICK_COUNT: u8 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u8 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u8 = 1;
pub const configENABLE_MPU: u8 = 0;
pub const configENABLE_FPU: u8 = 1;
pub const configENABLE_MVE: u8 = 0;
pub const configENABLE_TRUSTZONE: u8 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u8 = 0;
pub const configRUN_ADDITIONAL_TESTS: u8 = 0;
pub const configENABLE_PAC: u8 = 0;
pub const configENABLE_BTI: u8 = 0;
pub const ATOMIC_COMPARE_AND_SWAP_SUCCESS: u8 = 1;
pub const ATOMIC_COMPARE_AND_SWAP_FAILURE: u8 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 8] = b"V11.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u8 = 11;
pub const tskKERNEL_VERSION_MINOR: u8 = 2;
pub const tskKERNEL_VERSION_BUILD: u8 = 0;
pub const tskMPU_REGION_READ_ONLY: u8 = 1;
pub const tskMPU_REGION_READ_WRITE: u8 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u8 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u8 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u8 = 16;
pub const tskMPU_READ_PERMISSION: u8 = 1;
pub const tskMPU_WRITE_PERMISSION: u8 = 2;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u8 = 0;
pub const portSTACK_LIMIT_PADDING: u8 = 0;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::core::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::core::mem::align_of::<max_align_t>() - 16usize];
    [
        "Offset of field: max_align_t::__clang_max_align_nonce1",
    ][::core::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    [
        "Offset of field: max_align_t::__clang_max_align_nonce2",
    ][::core::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    [
        "Offset of field: __fsid_t::__val",
    ][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    pub fn ulGetRunTimeCounterValue() -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn vAssertCalled(
        pcFileName: *const ::core::ffi::c_char,
        ulLine: ::core::ffi::c_ulong,
    );
}
pub type TaskFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void),
>;
pub type StackType_t = ::core::ffi::c_ulong;
pub type BaseType_t = ::core::ffi::c_long;
pub type UBaseType_t = ::core::ffi::c_ulong;
pub type TickType_t = ::core::ffi::c_ulong;
unsafe extern "C" {
    pub fn vPortYield();
}
unsafe extern "C" {
    pub fn vPortDisableInterrupts();
}
unsafe extern "C" {
    pub fn vPortEnableInterrupts();
}
unsafe extern "C" {
    pub fn xPortSetInterruptMask() -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vPortClearInterruptMask(xMask: UBaseType_t);
}
unsafe extern "C" {
    pub fn vPortEnterCritical();
}
unsafe extern "C" {
    pub fn vPortExitCritical();
}
unsafe extern "C" {
    pub fn vPortThreadDying(
        pxTaskToDelete: *mut ::core::ffi::c_void,
        pxPendYield: *mut BaseType_t,
    );
}
unsafe extern "C" {
    pub fn vPortCancelThread(pxTaskToDelete: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn ulPortGetRunTime() -> u32;
}
unsafe extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxEndOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::core::ffi::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HeapRegion"][::core::mem::size_of::<HeapRegion>() - 16usize];
    ["Alignment of HeapRegion"][::core::mem::align_of::<HeapRegion>() - 8usize];
    [
        "Offset of field: HeapRegion::pucStartAddress",
    ][::core::mem::offset_of!(HeapRegion, pucStartAddress) - 0usize];
    [
        "Offset of field: HeapRegion::xSizeInBytes",
    ][::core::mem::offset_of!(HeapRegion, xSizeInBytes) - 8usize];
};
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xHeapStats {
    pub xAvailableHeapSpaceInBytes: usize,
    pub xSizeOfLargestFreeBlockInBytes: usize,
    pub xSizeOfSmallestFreeBlockInBytes: usize,
    pub xNumberOfFreeBlocks: usize,
    pub xMinimumEverFreeBytesRemaining: usize,
    pub xNumberOfSuccessfulAllocations: usize,
    pub xNumberOfSuccessfulFrees: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xHeapStats"][::core::mem::size_of::<xHeapStats>() - 56usize];
    ["Alignment of xHeapStats"][::core::mem::align_of::<xHeapStats>() - 8usize];
    [
        "Offset of field: xHeapStats::xAvailableHeapSpaceInBytes",
    ][::core::mem::offset_of!(xHeapStats, xAvailableHeapSpaceInBytes) - 0usize];
    [
        "Offset of field: xHeapStats::xSizeOfLargestFreeBlockInBytes",
    ][::core::mem::offset_of!(xHeapStats, xSizeOfLargestFreeBlockInBytes) - 8usize];
    [
        "Offset of field: xHeapStats::xSizeOfSmallestFreeBlockInBytes",
    ][::core::mem::offset_of!(xHeapStats, xSizeOfSmallestFreeBlockInBytes) - 16usize];
    [
        "Offset of field: xHeapStats::xNumberOfFreeBlocks",
    ][::core::mem::offset_of!(xHeapStats, xNumberOfFreeBlocks) - 24usize];
    [
        "Offset of field: xHeapStats::xMinimumEverFreeBytesRemaining",
    ][::core::mem::offset_of!(xHeapStats, xMinimumEverFreeBytesRemaining) - 32usize];
    [
        "Offset of field: xHeapStats::xNumberOfSuccessfulAllocations",
    ][::core::mem::offset_of!(xHeapStats, xNumberOfSuccessfulAllocations) - 40usize];
    [
        "Offset of field: xHeapStats::xNumberOfSuccessfulFrees",
    ][::core::mem::offset_of!(xHeapStats, xNumberOfSuccessfulFrees) - 48usize];
};
pub type HeapStats_t = xHeapStats;
unsafe extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
unsafe extern "C" {
    #[link_name = "\u{1}vPortGetHeapStats"]
    pub fn __vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
unsafe extern "C" {
    #[link_name = "\u{1}pvPortMalloc"]
    pub fn __pvPortMalloc(xWantedSize: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn pvPortCalloc(xNum: usize, xSize: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn vPortFree(pv: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn vPortInitialiseBlocks();
}
unsafe extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortResetHeapMinimumEverFreeHeapSize();
}
unsafe extern "C" {
    pub fn vPortHeapResetState();
}
unsafe extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::core::ffi::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST_ITEM"][::core::mem::size_of::<xSTATIC_LIST_ITEM>() - 40usize];
    [
        "Alignment of xSTATIC_LIST_ITEM",
    ][::core::mem::align_of::<xSTATIC_LIST_ITEM>() - 8usize];
    [
        "Offset of field: xSTATIC_LIST_ITEM::xDummy2",
    ][::core::mem::offset_of!(xSTATIC_LIST_ITEM, xDummy2) - 0usize];
    [
        "Offset of field: xSTATIC_LIST_ITEM::pvDummy3",
    ][::core::mem::offset_of!(xSTATIC_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xSTATIC_MINI_LIST_ITEM",
    ][::core::mem::size_of::<xSTATIC_MINI_LIST_ITEM>() - 24usize];
    [
        "Alignment of xSTATIC_MINI_LIST_ITEM",
    ][::core::mem::align_of::<xSTATIC_MINI_LIST_ITEM>() - 8usize];
    [
        "Offset of field: xSTATIC_MINI_LIST_ITEM::xDummy2",
    ][::core::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, xDummy2) - 0usize];
    [
        "Offset of field: xSTATIC_MINI_LIST_ITEM::pvDummy3",
    ][::core::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut ::core::ffi::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST"][::core::mem::size_of::<xSTATIC_LIST>() - 40usize];
    ["Alignment of xSTATIC_LIST"][::core::mem::align_of::<xSTATIC_LIST>() - 8usize];
    [
        "Offset of field: xSTATIC_LIST::uxDummy2",
    ][::core::mem::offset_of!(xSTATIC_LIST, uxDummy2) - 0usize];
    [
        "Offset of field: xSTATIC_LIST::pvDummy3",
    ][::core::mem::offset_of!(xSTATIC_LIST, pvDummy3) - 8usize];
    [
        "Offset of field: xSTATIC_LIST::xDummy4",
    ][::core::mem::offset_of!(xSTATIC_LIST, xDummy4) - 16usize];
};
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::core::ffi::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::core::ffi::c_void,
    pub ucDummy7: [u8; 12usize],
    pub uxDummy10: [UBaseType_t; 2usize],
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pxDummy14: *mut ::core::ffi::c_void,
    pub ulDummy16: u32,
    pub ulDummy18: [u32; 1usize],
    pub ucDummy19: [u8; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TCB"][::core::mem::size_of::<xSTATIC_TCB>() - 176usize];
    ["Alignment of xSTATIC_TCB"][::core::mem::align_of::<xSTATIC_TCB>() - 8usize];
    [
        "Offset of field: xSTATIC_TCB::pxDummy1",
    ][::core::mem::offset_of!(xSTATIC_TCB, pxDummy1) - 0usize];
    [
        "Offset of field: xSTATIC_TCB::xDummy3",
    ][::core::mem::offset_of!(xSTATIC_TCB, xDummy3) - 8usize];
    [
        "Offset of field: xSTATIC_TCB::uxDummy5",
    ][::core::mem::offset_of!(xSTATIC_TCB, uxDummy5) - 88usize];
    [
        "Offset of field: xSTATIC_TCB::pxDummy6",
    ][::core::mem::offset_of!(xSTATIC_TCB, pxDummy6) - 96usize];
    [
        "Offset of field: xSTATIC_TCB::ucDummy7",
    ][::core::mem::offset_of!(xSTATIC_TCB, ucDummy7) - 104usize];
    [
        "Offset of field: xSTATIC_TCB::uxDummy10",
    ][::core::mem::offset_of!(xSTATIC_TCB, uxDummy10) - 120usize];
    [
        "Offset of field: xSTATIC_TCB::uxDummy12",
    ][::core::mem::offset_of!(xSTATIC_TCB, uxDummy12) - 136usize];
    [
        "Offset of field: xSTATIC_TCB::pxDummy14",
    ][::core::mem::offset_of!(xSTATIC_TCB, pxDummy14) - 152usize];
    [
        "Offset of field: xSTATIC_TCB::ulDummy16",
    ][::core::mem::offset_of!(xSTATIC_TCB, ulDummy16) - 160usize];
    [
        "Offset of field: xSTATIC_TCB::ulDummy18",
    ][::core::mem::offset_of!(xSTATIC_TCB, ulDummy18) - 164usize];
    [
        "Offset of field: xSTATIC_TCB::ucDummy19",
    ][::core::mem::offset_of!(xSTATIC_TCB, ucDummy19) - 168usize];
};
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::core::ffi::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub pvDummy7: *mut ::core::ffi::c_void,
    pub uxDummy8: UBaseType_t,
    pub ucDummy9: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub uxDummy2: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xSTATIC_QUEUE__bindgen_ty_1",
    ][::core::mem::size_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    [
        "Alignment of xSTATIC_QUEUE__bindgen_ty_1",
    ][::core::mem::align_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: xSTATIC_QUEUE__bindgen_ty_1::pvDummy2",
    ][::core::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, pvDummy2) - 0usize];
    [
        "Offset of field: xSTATIC_QUEUE__bindgen_ty_1::uxDummy2",
    ][::core::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, uxDummy2) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_QUEUE"][::core::mem::size_of::<xSTATIC_QUEUE>() - 168usize];
    ["Alignment of xSTATIC_QUEUE"][::core::mem::align_of::<xSTATIC_QUEUE>() - 8usize];
    [
        "Offset of field: xSTATIC_QUEUE::pvDummy1",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, pvDummy1) - 0usize];
    [
        "Offset of field: xSTATIC_QUEUE::u",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, u) - 24usize];
    [
        "Offset of field: xSTATIC_QUEUE::xDummy3",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, xDummy3) - 32usize];
    [
        "Offset of field: xSTATIC_QUEUE::uxDummy4",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, uxDummy4) - 112usize];
    [
        "Offset of field: xSTATIC_QUEUE::ucDummy5",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, ucDummy5) - 136usize];
    [
        "Offset of field: xSTATIC_QUEUE::pvDummy7",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, pvDummy7) - 144usize];
    [
        "Offset of field: xSTATIC_QUEUE::uxDummy8",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, uxDummy8) - 152usize];
    [
        "Offset of field: xSTATIC_QUEUE::ucDummy9",
    ][::core::mem::offset_of!(xSTATIC_QUEUE, ucDummy9) - 160usize];
};
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub uxDummy3: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xSTATIC_EVENT_GROUP",
    ][::core::mem::size_of::<xSTATIC_EVENT_GROUP>() - 56usize];
    [
        "Alignment of xSTATIC_EVENT_GROUP",
    ][::core::mem::align_of::<xSTATIC_EVENT_GROUP>() - 8usize];
    [
        "Offset of field: xSTATIC_EVENT_GROUP::xDummy1",
    ][::core::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy1) - 0usize];
    [
        "Offset of field: xSTATIC_EVENT_GROUP::xDummy2",
    ][::core::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy2) - 8usize];
    [
        "Offset of field: xSTATIC_EVENT_GROUP::uxDummy3",
    ][::core::mem::offset_of!(xSTATIC_EVENT_GROUP, uxDummy3) - 48usize];
};
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::core::ffi::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut ::core::ffi::c_void,
    pub pvDummy6: TaskFunction_t,
    pub uxDummy7: UBaseType_t,
    pub ucDummy8: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TIMER"][::core::mem::size_of::<xSTATIC_TIMER>() - 88usize];
    ["Alignment of xSTATIC_TIMER"][::core::mem::align_of::<xSTATIC_TIMER>() - 8usize];
    [
        "Offset of field: xSTATIC_TIMER::pvDummy1",
    ][::core::mem::offset_of!(xSTATIC_TIMER, pvDummy1) - 0usize];
    [
        "Offset of field: xSTATIC_TIMER::xDummy2",
    ][::core::mem::offset_of!(xSTATIC_TIMER, xDummy2) - 8usize];
    [
        "Offset of field: xSTATIC_TIMER::xDummy3",
    ][::core::mem::offset_of!(xSTATIC_TIMER, xDummy3) - 48usize];
    [
        "Offset of field: xSTATIC_TIMER::pvDummy5",
    ][::core::mem::offset_of!(xSTATIC_TIMER, pvDummy5) - 56usize];
    [
        "Offset of field: xSTATIC_TIMER::pvDummy6",
    ][::core::mem::offset_of!(xSTATIC_TIMER, pvDummy6) - 64usize];
    [
        "Offset of field: xSTATIC_TIMER::uxDummy7",
    ][::core::mem::offset_of!(xSTATIC_TIMER, uxDummy7) - 72usize];
    [
        "Offset of field: xSTATIC_TIMER::ucDummy8",
    ][::core::mem::offset_of!(xSTATIC_TIMER, ucDummy8) - 80usize];
};
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [usize; 4usize],
    pub pvDummy2: [*mut ::core::ffi::c_void; 3usize],
    pub ucDummy3: u8,
    pub uxDummy4: UBaseType_t,
    pub uxDummy6: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xSTATIC_STREAM_BUFFER",
    ][::core::mem::size_of::<xSTATIC_STREAM_BUFFER>() - 80usize];
    [
        "Alignment of xSTATIC_STREAM_BUFFER",
    ][::core::mem::align_of::<xSTATIC_STREAM_BUFFER>() - 8usize];
    [
        "Offset of field: xSTATIC_STREAM_BUFFER::uxDummy1",
    ][::core::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy1) - 0usize];
    [
        "Offset of field: xSTATIC_STREAM_BUFFER::pvDummy2",
    ][::core::mem::offset_of!(xSTATIC_STREAM_BUFFER, pvDummy2) - 32usize];
    [
        "Offset of field: xSTATIC_STREAM_BUFFER::ucDummy3",
    ][::core::mem::offset_of!(xSTATIC_STREAM_BUFFER, ucDummy3) - 56usize];
    [
        "Offset of field: xSTATIC_STREAM_BUFFER::uxDummy4",
    ][::core::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy4) - 64usize];
    [
        "Offset of field: xSTATIC_STREAM_BUFFER::uxDummy6",
    ][::core::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy6) - 72usize];
};
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    /**
```text

< The value being listed.  In most cases this is used to sort the list in ascending order.
```*/
    pub xItemValue: TickType_t,
    /**
```text

< Pointer to the next ListItem_t in the list.
```*/
    pub pxNext: *mut xLIST_ITEM,
    /**
```text

< Pointer to the previous ListItem_t in the list.
```*/
    pub pxPrevious: *mut xLIST_ITEM,
    /**
```text

< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself.
```*/
    pub pvOwner: *mut ::core::ffi::c_void,
    /**
```text

< Pointer to the list in which this list item is placed (if any).
```*/
    pub pvContainer: *mut xLIST,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST_ITEM"][::core::mem::size_of::<xLIST_ITEM>() - 40usize];
    ["Alignment of xLIST_ITEM"][::core::mem::align_of::<xLIST_ITEM>() - 8usize];
    [
        "Offset of field: xLIST_ITEM::xItemValue",
    ][::core::mem::offset_of!(xLIST_ITEM, xItemValue) - 0usize];
    [
        "Offset of field: xLIST_ITEM::pxNext",
    ][::core::mem::offset_of!(xLIST_ITEM, pxNext) - 8usize];
    [
        "Offset of field: xLIST_ITEM::pxPrevious",
    ][::core::mem::offset_of!(xLIST_ITEM, pxPrevious) - 16usize];
    [
        "Offset of field: xLIST_ITEM::pvOwner",
    ][::core::mem::offset_of!(xLIST_ITEM, pvOwner) - 24usize];
    [
        "Offset of field: xLIST_ITEM::pvContainer",
    ][::core::mem::offset_of!(xLIST_ITEM, pvContainer) - 32usize];
};
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMINI_LIST_ITEM"][::core::mem::size_of::<xMINI_LIST_ITEM>() - 24usize];
    [
        "Alignment of xMINI_LIST_ITEM",
    ][::core::mem::align_of::<xMINI_LIST_ITEM>() - 8usize];
    [
        "Offset of field: xMINI_LIST_ITEM::xItemValue",
    ][::core::mem::offset_of!(xMINI_LIST_ITEM, xItemValue) - 0usize];
    [
        "Offset of field: xMINI_LIST_ITEM::pxNext",
    ][::core::mem::offset_of!(xMINI_LIST_ITEM, pxNext) - 8usize];
    [
        "Offset of field: xMINI_LIST_ITEM::pxPrevious",
    ][::core::mem::offset_of!(xMINI_LIST_ITEM, pxPrevious) - 16usize];
};
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    /**
```text

< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY ().
```*/
    pub pxIndex: *mut ListItem_t,
    /**
```text

< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker.
```*/
    pub xListEnd: MiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST"][::core::mem::size_of::<xLIST>() - 40usize];
    ["Alignment of xLIST"][::core::mem::align_of::<xLIST>() - 8usize];
    [
        "Offset of field: xLIST::uxNumberOfItems",
    ][::core::mem::offset_of!(xLIST, uxNumberOfItems) - 0usize];
    [
        "Offset of field: xLIST::pxIndex",
    ][::core::mem::offset_of!(xLIST, pxIndex) - 8usize];
    [
        "Offset of field: xLIST::xListEnd",
    ][::core::mem::offset_of!(xLIST, xListEnd) - 16usize];
};
pub type List_t = xLIST;
unsafe extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
unsafe extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
pub type CoRoutineHandle_t = *mut ::core::ffi::c_void;
pub type crCOROUTINE_CODE = ::core::option::Option<
    unsafe extern "C" fn(xHandle: CoRoutineHandle_t, uxIndex: UBaseType_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct corCoRoutineControlBlock {
    pub pxCoRoutineFunction: crCOROUTINE_CODE,
    /**
```text

< List item used to place the CRCB in ready and blocked queues.
```*/
    pub xGenericListItem: ListItem_t,
    /**
```text

< List item used to place the CRCB in event lists.
```*/
    pub xEventListItem: ListItem_t,
    /**
```text

< The priority of the co-routine in relation to other co-routines.
```*/
    pub uxPriority: UBaseType_t,
    /**
```text

< Used to distinguish between co-routines when multiple co-routines use the same co-routine function.
```*/
    pub uxIndex: UBaseType_t,
    /**
```text

< Used internally by the co-routine implementation.
```*/
    pub uxState: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of corCoRoutineControlBlock",
    ][::core::mem::size_of::<corCoRoutineControlBlock>() - 112usize];
    [
        "Alignment of corCoRoutineControlBlock",
    ][::core::mem::align_of::<corCoRoutineControlBlock>() - 8usize];
    [
        "Offset of field: corCoRoutineControlBlock::pxCoRoutineFunction",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, pxCoRoutineFunction) - 0usize];
    [
        "Offset of field: corCoRoutineControlBlock::xGenericListItem",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, xGenericListItem) - 8usize];
    [
        "Offset of field: corCoRoutineControlBlock::xEventListItem",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, xEventListItem) - 48usize];
    [
        "Offset of field: corCoRoutineControlBlock::uxPriority",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, uxPriority) - 88usize];
    [
        "Offset of field: corCoRoutineControlBlock::uxIndex",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, uxIndex) - 96usize];
    [
        "Offset of field: corCoRoutineControlBlock::uxState",
    ][::core::mem::offset_of!(corCoRoutineControlBlock, uxState) - 104usize];
};
pub type CRCB_t = corCoRoutineControlBlock;
unsafe extern "C" {
    /**
```text

 croutine. h
 @code{c}
 BaseType_t xCoRoutineCreate(
                               crCOROUTINE_CODE pxCoRoutineCode,
                               UBaseType_t uxPriority,
                               UBaseType_t uxIndex
                             );
 @endcode

 Create a new co-routine and add it to the list of co-routines that are
 ready to run.

 @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine
 functions require special syntax - see the co-routine section of the WEB
 documentation for more information.

 @param uxPriority The priority with respect to other co-routines at which
  the co-routine will run.

 @param uxIndex Used to distinguish between different co-routines that
 execute the same function.  See the example below and the co-routine section
 of the WEB documentation for further information.

 @return pdPASS if the co-routine was successfully created and added to a ready
 list, otherwise an error code defined with ProjDefs.h.

 Example usage:
 @code{c}
 // Co-routine to be created.
 void vFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 // This may not be necessary for const variables.
 static const char cLedToFlash[ 2 ] = { 5, 6 };
 static const TickType_t uxFlashRates[ 2 ] = { 200, 400 };

   // Must start every co-routine with a call to crSTART();
   crSTART( xHandle );

   for( ;; )
   {
       // This co-routine just delays for a fixed period, then toggles
       // an LED.  Two co-routines are created using this function, so
       // the uxIndex parameter is used to tell the co-routine which
       // LED to flash and how int32_t to delay.  This assumes xQueue has
       // already been created.
       vParTestToggleLED( cLedToFlash[ uxIndex ] );
       crDELAY( xHandle, uxFlashRates[ uxIndex ] );
   }

   // Must end every co-routine with a call to crEND();
   crEND();
 }

 // Function that creates two co-routines.
 void vOtherFunction( void )
 {
 uint8_t ucParameterToPass;
 TaskHandle_t xHandle;

   // Create two co-routines at priority 0.  The first is given index 0
   // so (from the code above) toggles LED 5 every 200 ticks.  The second
   // is given index 1 so toggles LED 6 every 400 ticks.
   for( uxIndex = 0; uxIndex < 2; uxIndex++ )
   {
       xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );
   }
 }
 @endcode
 \defgroup xCoRoutineCreate xCoRoutineCreate
 \ingroup Tasks
```*/
    pub fn xCoRoutineCreate(
        pxCoRoutineCode: crCOROUTINE_CODE,
        uxPriority: UBaseType_t,
        uxIndex: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 croutine. h
 @code{c}
 void vCoRoutineSchedule( void );
 @endcode

 Run a co-routine.

 vCoRoutineSchedule() executes the highest priority co-routine that is able
 to run.  The co-routine will execute until it either blocks, yields or is
 preempted by a task.  Co-routines execute cooperatively so one
 co-routine cannot be preempted by another, but can be preempted by a task.

 If an application comprises of both tasks and co-routines then
 vCoRoutineSchedule should be called from the idle task (in an idle task
 hook).

 Example usage:
 @code{c}
 // This idle task hook will schedule a co-routine each time it is called.
 // The rest of the idle task will execute between co-routine calls.
 void vApplicationIdleHook( void )
 {
  vCoRoutineSchedule();
 }

 // Alternatively, if you do not require any other part of the idle task to
 // execute, the idle task hook can call vCoRoutineSchedule() within an
 // infinite loop.
 void vApplicationIdleHook( void )
 {
  for( ;; )
  {
      vCoRoutineSchedule();
  }
 }
 @endcode
 \defgroup vCoRoutineSchedule vCoRoutineSchedule
 \ingroup Tasks
```*/
    pub fn vCoRoutineSchedule();
}
unsafe extern "C" {
    pub fn vCoRoutineAddToDelayedList(
        xTicksToDelay: TickType_t,
        pxEventList: *mut List_t,
    );
}
unsafe extern "C" {
    pub fn xCoRoutineRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vCoRoutineResetState();
}
/**
```text

 Type by which stream buffers are referenced.  For example, a call to
 xStreamBufferCreate() returns an StreamBufferHandle_t variable that can
 then be used as a parameter to xStreamBufferSend(), xStreamBufferReceive(),
 etc.
```*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StreamBufferDef_t {
    _unused: [u8; 0],
}
pub type StreamBufferHandle_t = *mut StreamBufferDef_t;
/**
```text

  Type used as a stream buffer's optional callback.
```*/
pub type StreamBufferCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(
        xStreamBuffer: StreamBufferHandle_t,
        xIsInsideISR: BaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ),
>;
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                           const void *pvTxData,
                           size_t xDataLengthBytes,
                           TickType_t xTicksToWait );
 @endcode

 Sends bytes to a stream buffer.  The bytes are copied into the stream buffer.

 ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 implementation (so also the message buffer implementation, as message buffers
 are built on top of stream buffers) assumes there is only one task or
 interrupt that will write to the buffer (the writer), and only one task or
 interrupt that will read from the buffer (the reader).  It is safe for the
 writer and reader to be different tasks or interrupts, but, unlike other
 FreeRTOS objects, it is not safe to have multiple different writers or
 multiple different readers.  If there are to be multiple different writers
 then the application writer must serialize calls to writing API functions
 (such as xStreamBufferSend()).  Likewise, if there are to be multiple
 different readers then the application writer must serialize calls to reading
 API functions (such as xStreamBufferReceive()).  One way to achieve such
 serialization in single core or SMP kernel is to place each API call inside a
 critical section and use a block time of 0.

 Use xStreamBufferSend() to write to a stream buffer from a task.  Use
 xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
 service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferSend() to be available.

 @param xStreamBuffer The handle of the stream buffer to which a stream is
 being sent.

 @param pvTxData A pointer to the buffer that holds the bytes to be copied
 into the stream buffer.

 @param xDataLengthBytes   The maximum number of bytes to copy from pvTxData
 into the stream buffer.

 @param xTicksToWait The maximum amount of time the task should remain in the
 Blocked state to wait for enough space to become available in the stream
 buffer, should the stream buffer contain too little space to hold the
 another xDataLengthBytes bytes.  The block time is specified in tick periods,
 so the absolute time it represents is dependent on the tick frequency.  The
 macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds
 into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will
 cause the task to wait indefinitely (without timing out), provided
 INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out
 before it can write all xDataLengthBytes into the buffer it will still write
 as many bytes as possible.  A task does not use any CPU time when it is in
 the blocked state.

 @return The number of bytes written to the stream buffer.  If a task times
 out before it can write all xDataLengthBytes into the buffer it will still
 write as many bytes as possible.

 Example use:
 @code{c}
 void vAFunction( StreamBufferHandle_t xStreamBuffer )
 {
 size_t xBytesSent;
 uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };
 char *pcStringToSend = "String to send";
 const TickType_t x100ms = pdMS_TO_TICKS( 100 );

  // Send an array to the stream buffer, blocking for a maximum of 100ms to
  // wait for enough space to be available in the stream buffer.
  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );

  if( xBytesSent != sizeof( ucArrayToSend ) )
  {
      // The call to xStreamBufferSend() times out before there was enough
      // space in the buffer for the data to be written, but it did
      // successfully write xBytesSent bytes.
  }

  // Send the string to the stream buffer.  Return immediately if there is not
  // enough space in the buffer.
  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );

  if( xBytesSent != strlen( pcStringToSend ) )
  {
      // The entire string could not be added to the stream buffer because
      // there was not enough free space in the buffer, but xBytesSent bytes
      // were sent.  Could try again to send the remaining bytes.
  }
 }
 @endcode
 \defgroup xStreamBufferSend xStreamBufferSend
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferSend(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                  const void *pvTxData,
                                  size_t xDataLengthBytes,
                                  BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 Interrupt safe version of the API function that sends a stream of bytes to
 the stream buffer.

 ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 implementation (so also the message buffer implementation, as message buffers
 are built on top of stream buffers) assumes there is only one task or
 interrupt that will write to the buffer (the writer), and only one task or
 interrupt that will read from the buffer (the reader).  It is safe for the
 writer and reader to be different tasks or interrupts, but, unlike other
 FreeRTOS objects, it is not safe to have multiple different writers or
 multiple different readers.  If there are to be multiple different writers
 then the application writer must serialize calls to writing API functions
 (such as xStreamBufferSend()).  Likewise, if there are to be multiple
 different readers then the application writer must serialize calls to reading
 API functions (such as xStreamBufferReceive()).  One way to achieve such
 serialization in single core or SMP kernel is to place each API call inside a
 critical section and use a block time of 0.

 Use xStreamBufferSend() to write to a stream buffer from a task.  Use
 xStreamBufferSendFromISR() to write to a stream buffer from an interrupt
 service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferSendFromISR() to be available.

 @param xStreamBuffer The handle of the stream buffer to which a stream is
 being sent.

 @param pvTxData A pointer to the data that is to be copied into the stream
 buffer.

 @param xDataLengthBytes The maximum number of bytes to copy from pvTxData
 into the stream buffer.

 @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
 have a task blocked on it waiting for data.  Calling
 xStreamBufferSendFromISR() can make data available, and so cause a task that
 was waiting for data to leave the Blocked state.  If calling
 xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the
 unblocked task has a priority higher than the currently executing task (the
 task that was interrupted), then, internally, xStreamBufferSendFromISR()
 will set *pxHigherPriorityTaskWoken to pdTRUE.  If
 xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a
 context switch should be performed before the interrupt is exited.  This will
 ensure that the interrupt returns directly to the highest priority Ready
 state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it
 is passed into the function.  See the example code below for an example.

 @return The number of bytes actually written to the stream buffer, which will
 be less than xDataLengthBytes if the stream buffer didn't have enough free
 space for all the bytes to be written.

 Example use:
 @code{c}
 // A stream buffer that has already been created.
 StreamBufferHandle_t xStreamBuffer;

 void vAnInterruptServiceRoutine( void )
 {
 size_t xBytesSent;
 char *pcStringToSend = "String to send";
 BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.

  // Attempt to send the string to the stream buffer.
  xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,
                                         ( void * ) pcStringToSend,
                                         strlen( pcStringToSend ),
                                         &xHigherPriorityTaskWoken );

  if( xBytesSent != strlen( pcStringToSend ) )
  {
      // There was not enough free space in the stream buffer for the entire
      // string to be written, ut xBytesSent bytes were written.
  }

  // If xHigherPriorityTaskWoken was set to pdTRUE inside
  // xStreamBufferSendFromISR() then a task that has a priority above the
  // priority of the currently executing task was unblocked and a context
  // switch should be performed to ensure the ISR returns to the unblocked
  // task.  In most FreeRTOS ports this is done by simply passing
  // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
  // variables value, and perform the context switch if necessary.  Check the
  // documentation for the port in use for port specific instructions.
  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 }
 @endcode
 \defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferSendFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                              void *pvRxData,
                              size_t xBufferLengthBytes,
                              TickType_t xTicksToWait );
 @endcode

 Receives bytes from a stream buffer.

 ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer
 implementation (so also the message buffer implementation, as message buffers
 are built on top of stream buffers) assumes there is only one task or
 interrupt that will write to the buffer (the writer), and only one task or
 interrupt that will read from the buffer (the reader).  It is safe for the
 writer and reader to be different tasks or interrupts, but, unlike other
 FreeRTOS objects, it is not safe to have multiple different writers or
 multiple different readers.  If there are to be multiple different writers
 then the application writer must serialize calls to writing API functions
 (such as xStreamBufferSend()).  Likewise, if there are to be multiple
 different readers then the application writer must serialize calls to reading
 API functions (such as xStreamBufferReceive()).  One way to achieve such
 serialization in single core or SMP kernel is to place each API call inside a
 critical section and use a block time of 0.

 Use xStreamBufferReceive() to read from a stream buffer from a task.  Use
 xStreamBufferReceiveFromISR() to read from a stream buffer from an
 interrupt service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferReceive() to be available.

 @param xStreamBuffer The handle of the stream buffer from which bytes are to
 be received.

 @param pvRxData A pointer to the buffer into which the received bytes will be
 copied.

 @param xBufferLengthBytes The length of the buffer pointed to by the
 pvRxData parameter.  This sets the maximum number of bytes to receive in one
 call.  xStreamBufferReceive will return as many bytes as possible up to a
 maximum set by xBufferLengthBytes.

 @param xTicksToWait The maximum amount of time the task should remain in the
 Blocked state to wait for data to become available if the stream buffer is
 empty.  xStreamBufferReceive() will return immediately if xTicksToWait is
 zero.  The block time is specified in tick periods, so the absolute time it
 represents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can
 be used to convert a time specified in milliseconds into a time specified in
 ticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait
 indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1
 in FreeRTOSConfig.h.  A task does not use any CPU time when it is in the
 Blocked state.

 @return The number of bytes actually read from the stream buffer, which will
 be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed
 out before xBufferLengthBytes were available.

 Example use:
 @code{c}
 void vAFunction( StreamBuffer_t xStreamBuffer )
 {
 uint8_t ucRxData[ 20 ];
 size_t xReceivedBytes;
 const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );

  // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.
  // Wait in the Blocked state (so not using any CPU processing time) for a
  // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be
  // available.
  xReceivedBytes = xStreamBufferReceive( xStreamBuffer,
                                         ( void * ) ucRxData,
                                         sizeof( ucRxData ),
                                         xBlockTime );

  if( xReceivedBytes > 0 )
  {
      // A ucRxData contains another xReceivedBytes bytes of data, which can
      // be processed here....
  }
 }
 @endcode
 \defgroup xStreamBufferReceive xStreamBufferReceive
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferReceive(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                     void *pvRxData,
                                     size_t xBufferLengthBytes,
                                     BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 An interrupt safe version of the API function that receives bytes from a
 stream buffer.

 Use xStreamBufferReceive() to read bytes from a stream buffer from a task.
 Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an
 interrupt service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferReceiveFromISR() to be available.

 @param xStreamBuffer The handle of the stream buffer from which a stream
 is being received.

 @param pvRxData A pointer to the buffer into which the received bytes are
 copied.

 @param xBufferLengthBytes The length of the buffer pointed to by the
 pvRxData parameter.  This sets the maximum number of bytes to receive in one
 call.  xStreamBufferReceive will return as many bytes as possible up to a
 maximum set by xBufferLengthBytes.

 @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
 have a task blocked on it waiting for space to become available.  Calling
 xStreamBufferReceiveFromISR() can make space available, and so cause a task
 that is waiting for space to leave the Blocked state.  If calling
 xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and
 the unblocked task has a priority higher than the currently executing task
 (the task that was interrupted), then, internally,
 xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
 If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a
 context switch should be performed before the interrupt is exited.  That will
 ensure the interrupt returns directly to the highest priority Ready state
 task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
 passed into the function.  See the code example below for an example.

 @return The number of bytes read from the stream buffer, if any.

 Example use:
 @code{c}
 // A stream buffer that has already been created.
 StreamBuffer_t xStreamBuffer;

 void vAnInterruptServiceRoutine( void )
 {
 uint8_t ucRxData[ 20 ];
 size_t xReceivedBytes;
 BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.

  // Receive the next stream from the stream buffer.
  xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,
                                                ( void * ) ucRxData,
                                                sizeof( ucRxData ),
                                                &xHigherPriorityTaskWoken );

  if( xReceivedBytes > 0 )
  {
      // ucRxData contains xReceivedBytes read from the stream buffer.
      // Process the stream here....
  }

  // If xHigherPriorityTaskWoken was set to pdTRUE inside
  // xStreamBufferReceiveFromISR() then a task that has a priority above the
  // priority of the currently executing task was unblocked and a context
  // switch should be performed to ensure the ISR returns to the unblocked
  // task.  In most FreeRTOS ports this is done by simply passing
  // xHigherPriorityTaskWoken into portYIELD_FROM_ISR(), which will test the
  // variables value, and perform the context switch if necessary.  Check the
  // documentation for the port in use for port specific instructions.
  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 }
 @endcode
 \defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferReceiveFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Deletes a stream buffer that was previously created using a call to
 xStreamBufferCreate() or xStreamBufferCreateStatic().  If the stream
 buffer was created using dynamic memory (that is, by xStreamBufferCreate()),
 then the allocated memory is freed.

 A stream buffer handle must not be used after the stream buffer has been
 deleted.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 vStreamBufferDelete() to be available.

 @param xStreamBuffer The handle of the stream buffer to be deleted.

 \defgroup vStreamBufferDelete vStreamBufferDelete
 \ingroup StreamBufferManagement
```*/
    pub fn vStreamBufferDelete(xStreamBuffer: StreamBufferHandle_t);
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Queries a stream buffer to see if it is full.  A stream buffer is full if it
 does not have any free space, and therefore cannot accept any more data.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferIsFull() to be available.

 @param xStreamBuffer The handle of the stream buffer being queried.

 @return If the stream buffer is full then pdTRUE is returned.  Otherwise
 pdFALSE is returned.

 \defgroup xStreamBufferIsFull xStreamBufferIsFull
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferIsFull(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Queries a stream buffer to see if it is empty.  A stream buffer is empty if
 it does not contain any data.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferIsEmpty() to be available.

 @param xStreamBuffer The handle of the stream buffer being queried.

 @return If the stream buffer is empty then pdTRUE is returned.  Otherwise
 pdFALSE is returned.

 \defgroup xStreamBufferIsEmpty xStreamBufferIsEmpty
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferIsEmpty(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Resets a stream buffer to its initial, empty, state.  Any data that was in
 the stream buffer is discarded.  A stream buffer can only be reset if there
 are no tasks blocked waiting to either send to or receive from the stream
 buffer.

 Use xStreamBufferReset() to reset a stream buffer from a task.
 Use xStreamBufferResetFromISR() to reset a stream buffer from an
 interrupt service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferReset() to be available.

 @param xStreamBuffer The handle of the stream buffer being reset.

 @return If the stream buffer is reset then pdPASS is returned.  If there was
 a task blocked waiting to send to or read from the stream buffer then the
 stream buffer is not reset and pdFAIL is returned.

 \defgroup xStreamBufferReset xStreamBufferReset
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferReset(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferResetFromISR( StreamBufferHandle_t xStreamBuffer );
 @endcode

 An interrupt safe version of the API function that resets the stream buffer.

 Resets a stream buffer to its initial, empty, state.  Any data that was in
 the stream buffer is discarded.  A stream buffer can only be reset if there
 are no tasks blocked waiting to either send to or receive from the stream
 buffer.

 Use xStreamBufferReset() to reset a stream buffer from a task.
 Use xStreamBufferResetFromISR() to reset a stream buffer from an
 interrupt service routine (ISR).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferResetFromISR() to be available.

 @param xStreamBuffer The handle of the stream buffer being reset.

 @return If the stream buffer is reset then pdPASS is returned.  If there was
 a task blocked waiting to send to or read from the stream buffer then the
 stream buffer is not reset and pdFAIL is returned.

 \defgroup xStreamBufferResetFromISR xStreamBufferResetFromISR
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferResetFromISR(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Queries a stream buffer to see how much free space it contains, which is
 equal to the amount of data that can be sent to the stream buffer before it
 is full.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferSpacesAvailable() to be available.

 @param xStreamBuffer The handle of the stream buffer being queried.

 @return The number of bytes that can be written to the stream buffer before
 the stream buffer would be full.

 \defgroup xStreamBufferSpacesAvailable xStreamBufferSpacesAvailable
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferSpacesAvailable(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Queries a stream buffer to see how much data it contains, which is equal to
 the number of bytes that can be read from the stream buffer before the stream
 buffer would be empty.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferBytesAvailable() to be available.

 @param xStreamBuffer The handle of the stream buffer being queried.

 @return The number of bytes that can be read from the stream buffer before
 the stream buffer would be empty.

 \defgroup xStreamBufferBytesAvailable xStreamBufferBytesAvailable
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferBytesAvailable(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel );
 @endcode

 A stream buffer's trigger level is the number of bytes that must be in the
 stream buffer before a task that is blocked on the stream buffer to
 wait for data is moved out of the blocked state.  For example, if a task is
 blocked on a read of an empty stream buffer that has a trigger level of 1
 then the task will be unblocked when a single byte is written to the buffer
 or the task's block time expires.  As another example, if a task is blocked
 on a read of an empty stream buffer that has a trigger level of 10 then the
 task will not be unblocked until the stream buffer contains at least 10 bytes
 or the task's block time expires.  If a reading task's block time expires
 before the trigger level is reached then the task will still receive however
 many bytes are actually available.  Setting a trigger level of 0 will result
 in a trigger level of 1 being used.  It is not valid to specify a trigger
 level that is greater than the buffer size.

 A trigger level is set when the stream buffer is created, and can be modified
 using xStreamBufferSetTriggerLevel().

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferSetTriggerLevel() to be available.

 @param xStreamBuffer The handle of the stream buffer being updated.

 @param xTriggerLevel The new trigger level for the stream buffer.

 @return If xTriggerLevel was less than or equal to the stream buffer's length
 then the trigger level will be updated and pdTRUE is returned.  Otherwise
 pdFALSE is returned.

 \defgroup xStreamBufferSetTriggerLevel xStreamBufferSetTriggerLevel
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferSetTriggerLevel(
        xStreamBuffer: StreamBufferHandle_t,
        xTriggerLevel: usize,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 For advanced users only.

 The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when
 data is sent to a message buffer or stream buffer.  If there was a task that
 was blocked on the message or stream buffer waiting for data to arrive then
 the sbSEND_COMPLETED() macro sends a notification to the task to remove it
 from the Blocked state.  xStreamBufferSendCompletedFromISR() does the same
 thing.  It is provided to enable application writers to implement their own
 version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.

 See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
 additional information.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferSendCompletedFromISR() to be available.

 @param xStreamBuffer The handle of the stream buffer to which data was
 written.

 @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
 initialised to pdFALSE before it is passed into
 xStreamBufferSendCompletedFromISR().  If calling
 xStreamBufferSendCompletedFromISR() removes a task from the Blocked state,
 and the task has a priority above the priority of the currently running task,
 then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
 context switch should be performed before exiting the ISR.

 @return If a task was removed from the Blocked state then pdTRUE is returned.
 Otherwise pdFALSE is returned.

 \defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferSendCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 For advanced users only.

 The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when
 data is read out of a message buffer or stream buffer.  If there was a task
 that was blocked on the message or stream buffer waiting for data to arrive
 then the sbRECEIVE_COMPLETED() macro sends a notification to the task to
 remove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()
 does the same thing.  It is provided to enable application writers to
 implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT
 ANY OTHER TIME.

 See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for
 additional information.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 xStreamBufferReceiveCompletedFromISR() to be available.

 @param xStreamBuffer The handle of the stream buffer from which data was
 read.

 @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be
 initialised to pdFALSE before it is passed into
 xStreamBufferReceiveCompletedFromISR().  If calling
 xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,
 and the task has a priority above the priority of the currently running task,
 then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a
 context switch should be performed before exiting the ISR.

 @return If a task was removed from the Blocked state then pdTRUE is returned.
 Otherwise pdFALSE is returned.

 \defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR
 \ingroup StreamBufferManagement
```*/
    pub fn xStreamBufferReceiveCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 UBaseType_t uxStreamBufferGetStreamBufferNotificationIndex( StreamBufferHandle_t xStreamBuffer );
 @endcode

 Get the task notification index used for the supplied stream buffer which can
 be set using vStreamBufferSetStreamBufferNotificationIndex. If the task
 notification index for the stream buffer is not changed using
 vStreamBufferSetStreamBufferNotificationIndex, this function returns the
 default value (tskDEFAULT_INDEX_TO_NOTIFY).

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 uxStreamBufferGetStreamBufferNotificationIndex() to be available.

 @param xStreamBuffer The handle of the stream buffer for which the task
 notification index is retrieved.

 @return The task notification index for the stream buffer.

 \defgroup uxStreamBufferGetStreamBufferNotificationIndex uxStreamBufferGetStreamBufferNotificationIndex
 \ingroup StreamBufferManagement
```*/
    pub fn uxStreamBufferGetStreamBufferNotificationIndex(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 stream_buffer.h

 @code{c}
 void vStreamBufferSetStreamBufferNotificationIndex ( StreamBuffer_t xStreamBuffer, UBaseType_t uxNotificationIndex );
 @endcode

 Set the task notification index used for the supplied stream buffer.
 Successive calls to stream buffer APIs (like xStreamBufferSend or
 xStreamBufferReceive) for this stream buffer will use this new index for
 their task notifications.

 If this function is not called, the default index (tskDEFAULT_INDEX_TO_NOTIFY)
 is used for task notifications. It is recommended to call this function
 before attempting to send or receive data from the stream buffer to avoid
 inconsistencies.

 configUSE_STREAM_BUFFERS must be set to 1 in for FreeRTOSConfig.h for
 vStreamBufferSetStreamBufferNotificationIndex() to be available.

 @param xStreamBuffer The handle of the stream buffer for which the task
 notification index is set.

 @param uxNotificationIndex The task notification index to set.

 \defgroup vStreamBufferSetStreamBufferNotificationIndex vStreamBufferSetStreamBufferNotificationIndex
 \ingroup StreamBufferManagement
```*/
    pub fn vStreamBufferSetStreamBufferNotificationIndex(
        xStreamBuffer: StreamBufferHandle_t,
        uxNotificationIndex: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn xStreamBufferGenericCreate(
        xBufferSizeBytes: usize,
        xTriggerLevelBytes: usize,
        xStreamBufferType: BaseType_t,
        pxSendCompletedCallback: StreamBufferCallbackFunction_t,
        pxReceiveCompletedCallback: StreamBufferCallbackFunction_t,
    ) -> StreamBufferHandle_t;
}
unsafe extern "C" {
    pub fn xStreamBufferNextMessageLengthBytes(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn vStreamBufferSetStreamBufferNumber(
        xStreamBuffer: StreamBufferHandle_t,
        uxStreamBufferNumber: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn uxStreamBufferGetStreamBufferNumber(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn ucStreamBufferGetStreamBufferType(xStreamBuffer: StreamBufferHandle_t) -> u8;
}
/**
```text

 Type by which message buffers are referenced.  For example, a call to
 xMessageBufferCreate() returns an MessageBufferHandle_t variable that can
 then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(),
 etc. Message buffer is essentially built as a stream buffer hence its handle
 is also set to same type as a stream buffer handle.
```*/
pub type MessageBufferHandle_t = StreamBufferHandle_t;
/**
```text

 task. h

 Type by which tasks are referenced.  For example, a call to xTaskCreate
 returns (via a pointer parameter) an TaskHandle_t variable that can then
 be used as a parameter to vTaskDelete to delete the task.

 \defgroup TaskHandle_t TaskHandle_t
 \ingroup Tasks
```*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type ConstTaskHandle_t = *const tskTaskControlBlock;
pub type TaskHookFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> BaseType_t,
>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = ::core::ffi::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTIME_OUT"][::core::mem::size_of::<xTIME_OUT>() - 16usize];
    ["Alignment of xTIME_OUT"][::core::mem::align_of::<xTIME_OUT>() - 8usize];
    [
        "Offset of field: xTIME_OUT::xOverflowCount",
    ][::core::mem::offset_of!(xTIME_OUT, xOverflowCount) - 0usize];
    [
        "Offset of field: xTIME_OUT::xTimeOnEntering",
    ][::core::mem::offset_of!(xTIME_OUT, xTimeOnEntering) - 8usize];
};
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::core::ffi::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMEMORY_REGION"][::core::mem::size_of::<xMEMORY_REGION>() - 16usize];
    ["Alignment of xMEMORY_REGION"][::core::mem::align_of::<xMEMORY_REGION>() - 8usize];
    [
        "Offset of field: xMEMORY_REGION::pvBaseAddress",
    ][::core::mem::offset_of!(xMEMORY_REGION, pvBaseAddress) - 0usize];
    [
        "Offset of field: xMEMORY_REGION::ulLengthInBytes",
    ][::core::mem::offset_of!(xMEMORY_REGION, ulLengthInBytes) - 8usize];
    [
        "Offset of field: xMEMORY_REGION::ulParameters",
    ][::core::mem::offset_of!(xMEMORY_REGION, ulParameters) - 12usize];
};
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::core::ffi::c_char,
    pub usStackDepth: StackType_t,
    pub pvParameters: *mut ::core::ffi::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_PARAMETERS"][::core::mem::size_of::<xTASK_PARAMETERS>() - 64usize];
    [
        "Alignment of xTASK_PARAMETERS",
    ][::core::mem::align_of::<xTASK_PARAMETERS>() - 8usize];
    [
        "Offset of field: xTASK_PARAMETERS::pvTaskCode",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, pvTaskCode) - 0usize];
    [
        "Offset of field: xTASK_PARAMETERS::pcName",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, pcName) - 8usize];
    [
        "Offset of field: xTASK_PARAMETERS::usStackDepth",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, usStackDepth) - 16usize];
    [
        "Offset of field: xTASK_PARAMETERS::pvParameters",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, pvParameters) - 24usize];
    [
        "Offset of field: xTASK_PARAMETERS::uxPriority",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, uxPriority) - 32usize];
    [
        "Offset of field: xTASK_PARAMETERS::puxStackBuffer",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, puxStackBuffer) - 40usize];
    [
        "Offset of field: xTASK_PARAMETERS::xRegions",
    ][::core::mem::offset_of!(xTASK_PARAMETERS, xRegions) - 48usize];
};
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const ::core::ffi::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: StackType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_STATUS"][::core::mem::size_of::<xTASK_STATUS>() - 72usize];
    ["Alignment of xTASK_STATUS"][::core::mem::align_of::<xTASK_STATUS>() - 8usize];
    [
        "Offset of field: xTASK_STATUS::xHandle",
    ][::core::mem::offset_of!(xTASK_STATUS, xHandle) - 0usize];
    [
        "Offset of field: xTASK_STATUS::pcTaskName",
    ][::core::mem::offset_of!(xTASK_STATUS, pcTaskName) - 8usize];
    [
        "Offset of field: xTASK_STATUS::xTaskNumber",
    ][::core::mem::offset_of!(xTASK_STATUS, xTaskNumber) - 16usize];
    [
        "Offset of field: xTASK_STATUS::eCurrentState",
    ][::core::mem::offset_of!(xTASK_STATUS, eCurrentState) - 24usize];
    [
        "Offset of field: xTASK_STATUS::uxCurrentPriority",
    ][::core::mem::offset_of!(xTASK_STATUS, uxCurrentPriority) - 32usize];
    [
        "Offset of field: xTASK_STATUS::uxBasePriority",
    ][::core::mem::offset_of!(xTASK_STATUS, uxBasePriority) - 40usize];
    [
        "Offset of field: xTASK_STATUS::ulRunTimeCounter",
    ][::core::mem::offset_of!(xTASK_STATUS, ulRunTimeCounter) - 48usize];
    [
        "Offset of field: xTASK_STATUS::pxStackBase",
    ][::core::mem::offset_of!(xTASK_STATUS, pxStackBase) - 56usize];
    [
        "Offset of field: xTASK_STATUS::usStackHighWaterMark",
    ][::core::mem::offset_of!(xTASK_STATUS, usStackHighWaterMark) - 64usize];
};
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = ::core::ffi::c_uint;
unsafe extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::core::ffi::c_char,
        uxStackDepth: StackType_t,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskDelete( TaskHandle_t xTaskToDelete );
 @endcode

 INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Remove a task from the RTOS real time kernel's management.  The task being
 deleted will be removed from all ready, blocked, suspended and event lists.

 NOTE:  The idle task is responsible for freeing the kernel allocated
 memory from tasks that have been deleted.  It is therefore important that
 the idle task is not starved of microcontroller processing time if your
 application makes any calls to vTaskDelete ().  Memory allocated by the
 task code is not automatically freed, and should be freed before the task
 is deleted.

 See the demo application file death.c for sample code that utilises
 vTaskDelete ().

 @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will
 cause the calling task to be deleted.

 Example usage:
 @code{c}
 void vOtherFunction( void )
 {
 TaskHandle_t xHandle;

   // Create the task, storing the handle.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

   // Use the handle to delete the task.
   vTaskDelete( xHandle );
 }
 @endcode
 \defgroup vTaskDelete vTaskDelete
 \ingroup Tasks
```*/
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskDelay( const TickType_t xTicksToDelay );
 @endcode

 Delay a task for a given number of ticks.  The actual time that the
 task remains blocked depends on the tick rate.  The constant
 portTICK_PERIOD_MS can be used to calculate real time from the tick
 rate - with the resolution of one tick period.

 INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
 See the configuration section for more information.


 vTaskDelay() specifies a time at which the task wishes to unblock relative to
 the time at which vTaskDelay() is called.  For example, specifying a block
 period of 100 ticks will cause the task to unblock 100 ticks after
 vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
 of controlling the frequency of a periodic task as the path taken through the
 code, as well as other task and interrupt activity, will affect the frequency
 at which vTaskDelay() gets called and therefore the time at which the task
 next executes.  See xTaskDelayUntil() for an alternative API function designed
 to facilitate fixed frequency execution.  It does this by specifying an
 absolute time (rather than a relative time) at which the calling task should
 unblock.

 @param xTicksToDelay The amount of time, in tick periods, that
 the calling task should block.

 Example usage:

 void vTaskFunction( void * pvParameters )
 {
 // Block for 500ms.
 const TickType_t xDelay = 500 / portTICK_PERIOD_MS;

   for( ;; )
   {
       // Simply toggle the LED every 500ms, blocking between each toggle.
       vToggleLED();
       vTaskDelay( xDelay );
   }
 }

 \defgroup vTaskDelay vTaskDelay
 \ingroup TaskCtrl
```*/
    #[link_name = "\u{1}vTaskDelay"]
    pub fn __vTaskDelay(xTicksToDelay: TickType_t);
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );
 @endcode

 INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Delay a task until a specified time.  This function can be used by periodic
 tasks to ensure a constant execution frequency.

 This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
 cause a task to block for the specified number of ticks from the time vTaskDelay () is
 called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
 execution frequency as the time between a task starting to execute and that task
 calling vTaskDelay () may not be fixed [the task may take a different path though the
 code between calls, or may get interrupted or preempted a different number of times
 each time it executes].

 Whereas vTaskDelay () specifies a wake time relative to the time at which the function
 is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
 unblock.

 The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a
 time specified in milliseconds with a resolution of one tick period.

 @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
 task was last unblocked.  The variable must be initialised with the current time
 prior to its first use (see the example below).  Following this the variable is
 automatically updated within xTaskDelayUntil ().

 @param xTimeIncrement The cycle time period.  The task will be unblocked at
 time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the
 same xTimeIncrement parameter value will cause the task to execute with
 a fixed interface period.

 @return Value which can be used to check whether the task was actually delayed.
 Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not
 be delayed if the next expected wake time is in the past.

 Example usage:
 @code{c}
 // Perform an action every 10 ticks.
 void vTaskFunction( void * pvParameters )
 {
 TickType_t xLastWakeTime;
 const TickType_t xFrequency = 10;
 BaseType_t xWasDelayed;

     // Initialise the xLastWakeTime variable with the current time.
     xLastWakeTime = xTaskGetTickCount ();
     for( ;; )
     {
         // Wait for the next cycle.
         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );

         // Perform action here. xWasDelayed value can be used to determine
         // whether a deadline was missed if the code here took too long.
     }
 }
 @endcode
 \defgroup xTaskDelayUntil xTaskDelayUntil
 \ingroup TaskCtrl
```*/
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
 @endcode

 INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Obtain the priority of any task.

 @param xTask Handle of the task to be queried.  Passing a NULL
 handle results in the priority of the calling task being returned.

 @return The priority of xTask.

 Example usage:
 @code{c}
 void vAFunction( void )
 {
 TaskHandle_t xHandle;

   // Create a task, storing the handle.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

   // ...

   // Use the handle to obtain the priority of the created task.
   // It was created with tskIDLE_PRIORITY, but may have changed
   // it itself.
   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
   {
       // The task has changed it's priority.
   }

   // ...

   // Is our priority higher than the created task?
   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
   {
       // Our priority (obtained using NULL handle) is higher.
   }
 }
 @endcode
 \defgroup uxTaskPriorityGet uxTaskPriorityGet
 \ingroup TaskCtrl
```*/
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );
 @endcode

 A version of uxTaskPriorityGet() that can be used from an ISR.
```*/
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 UBaseType_t uxTaskBasePriorityGet( const TaskHandle_t xTask );
 @endcode

 INCLUDE_uxTaskPriorityGet and configUSE_MUTEXES must be defined as 1 for this
 function to be available. See the configuration section for more information.

 Obtain the base priority of any task.

 @param xTask Handle of the task to be queried.  Passing a NULL
 handle results in the base priority of the calling task being returned.

 @return The base priority of xTask.

 \defgroup uxTaskPriorityGet uxTaskBasePriorityGet
 \ingroup TaskCtrl
```*/
    pub fn uxTaskBasePriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 UBaseType_t uxTaskBasePriorityGetFromISR( const TaskHandle_t xTask );
 @endcode

 A version of uxTaskBasePriorityGet() that can be used from an ISR.
```*/
    pub fn uxTaskBasePriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
unsafe extern "C" {
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );
 @endcode

 INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Set the priority of any task.

 A context switch will occur before the function returns if the priority
 being set is higher than the currently executing task.

 @param xTask Handle to the task for which the priority is being set.
 Passing a NULL handle results in the priority of the calling task being set.

 @param uxNewPriority The priority to which the task will be set.

 Example usage:
 @code{c}
 void vAFunction( void )
 {
 TaskHandle_t xHandle;

   // Create a task, storing the handle.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

   // ...

   // Use the handle to raise the priority of the created task.
   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );

   // ...

   // Use a NULL handle to raise our priority to the same value.
   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
 }
 @endcode
 \defgroup vTaskPrioritySet vTaskPrioritySet
 \ingroup TaskCtrl
```*/
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskSuspend( TaskHandle_t xTaskToSuspend );
 @endcode

 INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Suspend any task.  When suspended a task will never get any microcontroller
 processing time, no matter what its priority.

 Calls to vTaskSuspend are not accumulative -
 i.e. calling vTaskSuspend () twice on the same task still only requires one
 call to vTaskResume () to ready the suspended task.

 @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
 handle will cause the calling task to be suspended.

 Example usage:
 @code{c}
 void vAFunction( void )
 {
 TaskHandle_t xHandle;

   // Create a task, storing the handle.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

   // ...

   // Use the handle to suspend the created task.
   vTaskSuspend( xHandle );

   // ...

   // The created task will not run during this period, unless
   // another task calls vTaskResume( xHandle ).

   //...


   // Suspend ourselves.
   vTaskSuspend( NULL );

   // We cannot get here unless another task calls vTaskResume
   // with our handle as the parameter.
 }
 @endcode
 \defgroup vTaskSuspend vTaskSuspend
 \ingroup TaskCtrl
```*/
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskResume( TaskHandle_t xTaskToResume );
 @endcode

 INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
 See the configuration section for more information.

 Resumes a suspended task.

 A task that has been suspended by one or more calls to vTaskSuspend ()
 will be made available for running again by a single call to
 vTaskResume ().

 @param xTaskToResume Handle to the task being readied.

 Example usage:
 @code{c}
 void vAFunction( void )
 {
 TaskHandle_t xHandle;

   // Create a task, storing the handle.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );

   // ...

   // Use the handle to suspend the created task.
   vTaskSuspend( xHandle );

   // ...

   // The created task will not run during this period, unless
   // another task calls vTaskResume( xHandle ).

   //...


   // Resume the suspended task ourselves.
   vTaskResume( xHandle );

   // The created task will once again get microcontroller processing
   // time in accordance with its priority within the system.
 }
 @endcode
 \defgroup vTaskResume vTaskResume
 \ingroup TaskCtrl
```*/
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void xTaskResumeFromISR( TaskHandle_t xTaskToResume );
 @endcode

 INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
 available.  See the configuration section for more information.

 An implementation of vTaskResume() that can be called from within an ISR.

 A task that has been suspended by one or more calls to vTaskSuspend ()
 will be made available for running again by a single call to
 xTaskResumeFromISR ().

 xTaskResumeFromISR() should not be used to synchronise a task with an
 interrupt if there is a chance that the interrupt could arrive prior to the
 task being suspended - as this can lead to interrupts being missed. Use of a
 semaphore as a synchronisation mechanism would avoid this eventuality.

 @param xTaskToResume Handle to the task being readied.

 @return pdTRUE if resuming the task should result in a context switch,
 otherwise pdFALSE. This is used by the ISR to determine if a context switch
 may be required following the ISR.

 \defgroup vTaskResumeFromISR vTaskResumeFromISR
 \ingroup TaskCtrl
```*/
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskStartScheduler( void );
 @endcode

 Starts the real time kernel tick processing.  After calling the kernel
 has control over which tasks are executed and when.

 See the demo application file main.c for an example of creating
 tasks and starting the kernel.

 Example usage:
 @code{c}
 void vAFunction( void )
 {
   // Create at least one task before starting the kernel.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );

   // Start the real time kernel with preemption.
   vTaskStartScheduler ();

   // Will not get here unless a task calls vTaskEndScheduler ()
 }
 @endcode

 \defgroup vTaskStartScheduler vTaskStartScheduler
 \ingroup SchedulerControl
```*/
    pub fn vTaskStartScheduler();
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskEndScheduler( void );
 @endcode

 NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
 in place of DOS, implements this function.

 Stops the real time kernel tick.  All created tasks will be automatically
 deleted and multitasking (either preemptive or cooperative) will
 stop.  Execution then resumes from the point where vTaskStartScheduler ()
 was called, as if vTaskStartScheduler () had just returned.

 See the demo application file main. c in the demo/PC directory for an
 example that uses vTaskEndScheduler ().

 vTaskEndScheduler () requires an exit function to be defined within the
 portable layer (see vPortEndScheduler () in port. c for the PC port).  This
 performs hardware specific operations such as stopping the kernel tick.

 vTaskEndScheduler () will cause all of the resources allocated by the
 kernel to be freed - but will not free resources allocated by application
 tasks.

 Example usage:
 @code{c}
 void vTaskCode( void * pvParameters )
 {
   for( ;; )
   {
       // Task code goes here.

       // At some point we want to end the real time kernel processing
       // so call ...
       vTaskEndScheduler ();
   }
 }

 void vAFunction( void )
 {
   // Create at least one task before starting the kernel.
   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );

   // Start the real time kernel with preemption.
   vTaskStartScheduler ();

   // Will only get here when the vTaskCode () task has called
   // vTaskEndScheduler ().  When we get here we are back to single task
   // execution.
 }
 @endcode

 \defgroup vTaskEndScheduler vTaskEndScheduler
 \ingroup SchedulerControl
```*/
    pub fn vTaskEndScheduler();
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskSuspendAll( void );
 @endcode

 Suspends the scheduler without disabling interrupts.  Context switches will
 not occur while the scheduler is suspended.

 After calling vTaskSuspendAll () the calling task will continue to execute
 without risk of being swapped out until a call to xTaskResumeAll () has been
 made.

 API functions that have the potential to cause a context switch (for example,
 xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
 is suspended.

 Example usage:
 @code{c}
 void vTask1( void * pvParameters )
 {
   for( ;; )
   {
       // Task code goes here.

       // ...

       // At some point the task wants to perform a long operation during
       // which it does not want to get swapped out.  It cannot use
       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
       // operation may cause interrupts to be missed - including the
       // ticks.

       // Prevent the real time kernel swapping out the task.
       vTaskSuspendAll ();

       // Perform the operation here.  There is no need to use critical
       // sections as we have all the microcontroller processing time.
       // During this time interrupts will still operate and the kernel
       // tick count will be maintained.

       // ...

       // The operation is complete.  Restart the kernel.
       xTaskResumeAll ();
   }
 }
 @endcode
 \defgroup vTaskSuspendAll vTaskSuspendAll
 \ingroup SchedulerControl
```*/
    pub fn vTaskSuspendAll();
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskResumeAll( void );
 @endcode

 Resumes scheduler activity after it was suspended by a call to
 vTaskSuspendAll().

 xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
 that were previously suspended by a call to vTaskSuspend().

 @return If resuming the scheduler caused a context switch then pdTRUE is
         returned, otherwise pdFALSE is returned.

 Example usage:
 @code{c}
 void vTask1( void * pvParameters )
 {
   for( ;; )
   {
       // Task code goes here.

       // ...

       // At some point the task wants to perform a long operation during
       // which it does not want to get swapped out.  It cannot use
       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
       // operation may cause interrupts to be missed - including the
       // ticks.

       // Prevent the real time kernel swapping out the task.
       vTaskSuspendAll ();

       // Perform the operation here.  There is no need to use critical
       // sections as we have all the microcontroller processing time.
       // During this time interrupts will still operate and the real
       // time kernel tick count will be maintained.

       // ...

       // The operation is complete.  Restart the kernel.  We want to force
       // a context switch - but there is no point if resuming the scheduler
       // caused a context switch already.
       if( !xTaskResumeAll () )
       {
            taskYIELD ();
       }
   }
 }
 @endcode
 \defgroup xTaskResumeAll xTaskResumeAll
 \ingroup SchedulerControl
```*/
    pub fn xTaskResumeAll() -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 TickType_t xTaskGetTickCount( void );
 @endcode

 @return The count of ticks since vTaskStartScheduler was called.

 \defgroup xTaskGetTickCount xTaskGetTickCount
 \ingroup TaskUtils
```*/
    pub fn xTaskGetTickCount() -> TickType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 TickType_t xTaskGetTickCountFromISR( void );
 @endcode

 @return The count of ticks since vTaskStartScheduler was called.

 This is a version of xTaskGetTickCount() that is safe to be called from an
 ISR - provided that TickType_t is the natural word size of the
 microcontroller being used or interrupt nesting is either not supported or
 not being used.

 \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
 \ingroup TaskUtils
```*/
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 uint16_t uxTaskGetNumberOfTasks( void );
 @endcode

 @return The number of tasks that the real time kernel is currently managing.
 This includes all ready, blocked and suspended tasks.  A task that
 has been deleted but not yet freed by the idle task will also be
 included in the count.

 \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
 \ingroup TaskUtils
```*/
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 char *pcTaskGetName( TaskHandle_t xTaskToQuery );
 @endcode

 @return The text (human readable) name of the task referenced by the handle
 xTaskToQuery.  A task can query its own name by either passing in its own
 handle, or by setting xTaskToQuery to NULL.

 \defgroup pcTaskGetName pcTaskGetName
 \ingroup TaskUtils
```*/
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );
 @endcode

 Sets pxHookFunction to be the task hook function used by the task xTask.
 Passing xTask as NULL has the effect of setting the calling tasks hook
 function.
```*/
    pub fn vTaskSetApplicationTaskTag(
        xTask: TaskHandle_t,
        pxHookFunction: TaskHookFunction_t,
    );
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 void xTaskGetApplicationTaskTag( TaskHandle_t xTask );
 @endcode

 Returns the pxHookFunction value assigned to the task xTask.  Do not
 call from an interrupt service routine - call
 xTaskGetApplicationTaskTagFromISR() instead.
```*/
    pub fn xTaskGetApplicationTaskTag(xTask: TaskHandle_t) -> TaskHookFunction_t;
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 void xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask );
 @endcode

 Returns the pxHookFunction value assigned to the task xTask.  Can
 be called from an interrupt service routine.
```*/
    pub fn xTaskGetApplicationTaskTagFromISR(xTask: TaskHandle_t) -> TaskHookFunction_t;
}
unsafe extern "C" {
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xTaskGetIdleTaskHandleForCore(xCoreID: BaseType_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vTaskListTasks(
        pcWriteBuffer: *mut ::core::ffi::c_char,
        uxBufferLength: usize,
    );
}
unsafe extern "C" {
    pub fn vTaskGetRunTimeStatistics(
        pcWriteBuffer: *mut ::core::ffi::c_char,
        uxBufferLength: usize,
    );
}
unsafe extern "C" {
    pub fn ulTaskGetRunTimeCounter(xTask: TaskHandle_t) -> u32;
}
unsafe extern "C" {
    pub fn ulTaskGetRunTimePercent(xTask: TaskHandle_t) -> u32;
}
unsafe extern "C" {
    pub fn ulTaskGetIdleRunTimeCounter() -> u32;
}
unsafe extern "C" {
    pub fn ulTaskGetIdleRunTimePercent() -> u32;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );
 BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );
 @endcode

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 functions to be available.

 Sends a direct to task notification to a task, with an optional value and
 action.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 Events can be sent to a task using an intermediary object.  Examples of such
 objects are queues, semaphores, mutexes and event groups.  Task notifications
 are a method of sending an event directly to a task without the need for such
 an intermediary object.

 A notification sent to a task can optionally perform an action, such as
 update, overwrite or increment one of the task's notification values.  In
 that way task notifications can be used to send data to a task, or be used as
 light weight and fast binary or counting semaphores.

 A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to
 [optionally] block to wait for a notification to be pending.  The task does
 not consume any CPU time while it is in the Blocked state.

 A notification sent to a task will remain pending until it is cleared by the
 task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 un-indexed equivalents).  If the task was already in the Blocked state to
 wait for a notification when the notification arrives then the task will
 automatically be removed from the Blocked state (unblocked) and the
 notification cleared.

 **NOTE** Each notification within the array operates independently - a task
 can only block on one notification within the array at a time and will not be
 unblocked by a notification sent to any other array index.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  xTaskNotify() is the original API function, and remains backward
 compatible by always operating on the notification value at index 0 in the
 array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()
 with the uxIndexToNotify parameter set to 0.

 @param xTaskToNotify The handle of the task being notified.  The handle to a
 task can be returned from the xTaskCreate() API function used to create the
 task, and the handle of the currently running task can be obtained by calling
 xTaskGetCurrentTaskHandle().

 @param uxIndexToNotify The index within the target task's array of
 notification values to which the notification is to be sent.  uxIndexToNotify
 must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does
 not have this parameter and always sends notifications to index 0.

 @param ulValue Data that can be sent with the notification.  How the data is
 used depends on the value of the eAction parameter.

 @param eAction Specifies how the notification updates the task's notification
 value, if at all.  Valid values for eAction are as follows:

 eSetBits -
 The target notification value is bitwise ORed with ulValue.
 xTaskNotifyIndexed() always returns pdPASS in this case.

 eIncrement -
 The target notification value is incremented.  ulValue is not used and
 xTaskNotifyIndexed() always returns pdPASS in this case.

 eSetValueWithOverwrite -
 The target notification value is set to the value of ulValue, even if the
 task being notified had not yet processed the previous notification at the
 same array index (the task already had a notification pending at that index).
 xTaskNotifyIndexed() always returns pdPASS in this case.

 eSetValueWithoutOverwrite -
 If the task being notified did not already have a notification pending at the
 same array index then the target notification value is set to ulValue and
 xTaskNotifyIndexed() will return pdPASS.  If the task being notified already
 had a notification pending at the same array index then no action is
 performed and pdFAIL is returned.

 eNoAction -
 The task receives a notification at the specified array index without the
 notification value at that index being updated.  ulValue is not used and
 xTaskNotifyIndexed() always returns pdPASS in this case.

 pulPreviousNotificationValue -
 Can be used to pass out the subject task's notification value before any
 bits are modified by the notify function.

 @return Dependent on the value of eAction.  See the description of the
 eAction parameter.

 \defgroup xTaskNotifyIndexed xTaskNotifyIndexed
 \ingroup TaskNotifications
```*/
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
 BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 functions to be available.

 A version of xTaskNotifyIndexed() that can be used from an interrupt service
 routine (ISR).

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 Events can be sent to a task using an intermediary object.  Examples of such
 objects are queues, semaphores, mutexes and event groups.  Task notifications
 are a method of sending an event directly to a task without the need for such
 an intermediary object.

 A notification sent to a task can optionally perform an action, such as
 update, overwrite or increment one of the task's notification values.  In
 that way task notifications can be used to send data to a task, or be used as
 light weight and fast binary or counting semaphores.

 A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
 notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
 to wait for a notification value to have a non-zero value.  The task does
 not consume any CPU time while it is in the Blocked state.

 A notification sent to a task will remain pending until it is cleared by the
 task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 un-indexed equivalents).  If the task was already in the Blocked state to
 wait for a notification when the notification arrives then the task will
 automatically be removed from the Blocked state (unblocked) and the
 notification cleared.

 **NOTE** Each notification within the array operates independently - a task
 can only block on one notification within the array at a time and will not be
 unblocked by a notification sent to any other array index.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  xTaskNotifyFromISR() is the original API function, and remains
 backward compatible by always operating on the notification value at index 0
 within the array. Calling xTaskNotifyFromISR() is equivalent to calling
 xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.

 @param uxIndexToNotify The index within the target task's array of
 notification values to which the notification is to be sent.  uxIndexToNotify
 must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()
 does not have this parameter and always sends notifications to index 0.

 @param xTaskToNotify The handle of the task being notified.  The handle to a
 task can be returned from the xTaskCreate() API function used to create the
 task, and the handle of the currently running task can be obtained by calling
 xTaskGetCurrentTaskHandle().

 @param ulValue Data that can be sent with the notification.  How the data is
 used depends on the value of the eAction parameter.

 @param eAction Specifies how the notification updates the task's notification
 value, if at all.  Valid values for eAction are as follows:

 eSetBits -
 The task's notification value is bitwise ORed with ulValue.  xTaskNotify()
 always returns pdPASS in this case.

 eIncrement -
 The task's notification value is incremented.  ulValue is not used and
 xTaskNotify() always returns pdPASS in this case.

 eSetValueWithOverwrite -
 The task's notification value is set to the value of ulValue, even if the
 task being notified had not yet processed the previous notification (the
 task already had a notification pending).  xTaskNotify() always returns
 pdPASS in this case.

 eSetValueWithoutOverwrite -
 If the task being notified did not already have a notification pending then
 the task's notification value is set to ulValue and xTaskNotify() will
 return pdPASS.  If the task being notified already had a notification
 pending then no action is performed and pdFAIL is returned.

 eNoAction -
 The task receives a notification without its notification value being
 updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
 this case.

 @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
 *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
 task to which the notification was sent to leave the Blocked state, and the
 unblocked task has a priority higher than the currently running task.  If
 xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
 be requested before the interrupt is exited.  How a context switch is
 requested from an ISR is dependent on the port - see the documentation page
 for the port in use.

 @return Dependent on the value of eAction.  See the description of the
 eAction parameter.

 \defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR
 \ingroup TaskNotifications
```*/
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );

 BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );
 @endcode

 Waits for a direct to task notification to be pending at a given index within
 an array of direct to task notifications.

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
 function to be available.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 Events can be sent to a task using an intermediary object.  Examples of such
 objects are queues, semaphores, mutexes and event groups.  Task notifications
 are a method of sending an event directly to a task without the need for such
 an intermediary object.

 A notification sent to a task can optionally perform an action, such as
 update, overwrite or increment one of the task's notification values.  In
 that way task notifications can be used to send data to a task, or be used as
 light weight and fast binary or counting semaphores.

 A notification sent to a task will remain pending until it is cleared by the
 task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
 un-indexed equivalents).  If the task was already in the Blocked state to
 wait for a notification when the notification arrives then the task will
 automatically be removed from the Blocked state (unblocked) and the
 notification cleared.

 A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
 notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
 to wait for a notification value to have a non-zero value.  The task does
 not consume any CPU time while it is in the Blocked state.

 **NOTE** Each notification within the array operates independently - a task
 can only block on one notification within the array at a time and will not be
 unblocked by a notification sent to any other array index.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  xTaskNotifyWait() is the original API function, and remains backward
 compatible by always operating on the notification value at index 0 in the
 array. Calling xTaskNotifyWait() is equivalent to calling
 xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.

 @param uxIndexToWaitOn The index within the calling task's array of
 notification values on which the calling task will wait for a notification to
 be received.  uxIndexToWaitOn must be less than
 configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does
 not have this parameter and always waits for notifications on index 0.

 @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
 will be cleared in the calling task's notification value before the task
 checks to see if any notifications are pending, and optionally blocks if no
 notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
 limits.h is included) or 0xffffffffU (if limits.h is not included) will have
 the effect of resetting the task's notification value to 0.  Setting
 ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.

 @param ulBitsToClearOnExit If a notification is pending or received before
 the calling task exits the xTaskNotifyWait() function then the task's
 notification value (see the xTaskNotify() API function) is passed out using
 the pulNotificationValue parameter.  Then any bits that are set in
 ulBitsToClearOnExit will be cleared in the task's notification value (note
 *pulNotificationValue is set before any bits are cleared).  Setting
 ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
 (if limits.h is not included) will have the effect of resetting the task's
 notification value to 0 before the function exits.  Setting
 ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
 when the function exits (in which case the value passed out in
 pulNotificationValue will match the task's notification value).

 @param pulNotificationValue Used to pass the task's notification value out
 of the function.  Note the value passed out will not be effected by the
 clearing of any bits caused by ulBitsToClearOnExit being non-zero.

 @param xTicksToWait The maximum amount of time that the task should wait in
 the Blocked state for a notification to be received, should a notification
 not already be pending when xTaskNotifyWait() was called.  The task
 will not consume any processing time while it is in the Blocked state.  This
 is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be
 used to convert a time specified in milliseconds to a time specified in
 ticks.

 @return If a notification was received (including notifications that were
 already pending when xTaskNotifyWait was called) then pdPASS is
 returned.  Otherwise pdFAIL is returned.

 \defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed
 \ingroup TaskNotifications
```*/
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );
 void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
 @endcode

 A version of xTaskNotifyGiveIndexed() that can be called from an interrupt
 service routine (ISR).

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
 to be available.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 Events can be sent to a task using an intermediary object.  Examples of such
 objects are queues, semaphores, mutexes and event groups.  Task notifications
 are a method of sending an event directly to a task without the need for such
 an intermediary object.

 A notification sent to a task can optionally perform an action, such as
 update, overwrite or increment one of the task's notification values.  In
 that way task notifications can be used to send data to a task, or be used as
 light weight and fast binary or counting semaphores.

 vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications
 are used as light weight and faster binary or counting semaphore equivalents.
 Actual FreeRTOS semaphores are given from an ISR using the
 xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
 a task notification is vTaskNotifyGiveIndexedFromISR().

 When task notifications are being used as a binary or counting semaphore
 equivalent then the task being notified should wait for the notification
 using the ulTaskNotifyTakeIndexed() API function rather than the
 xTaskNotifyWaitIndexed() API function.

 **NOTE** Each notification within the array operates independently - a task
 can only block on one notification within the array at a time and will not be
 unblocked by a notification sent to any other array index.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  xTaskNotifyFromISR() is the original API function, and remains
 backward compatible by always operating on the notification value at index 0
 within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling
 xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.

 @param xTaskToNotify The handle of the task being notified.  The handle to a
 task can be returned from the xTaskCreate() API function used to create the
 task, and the handle of the currently running task can be obtained by calling
 xTaskGetCurrentTaskHandle().

 @param uxIndexToNotify The index within the target task's array of
 notification values to which the notification is to be sent.  uxIndexToNotify
 must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 xTaskNotifyGiveFromISR() does not have this parameter and always sends
 notifications to index 0.

 @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
 *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
 task to which the notification was sent to leave the Blocked state, and the
 unblocked task has a priority higher than the currently running task.  If
 vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
 should be requested before the interrupt is exited.  How a context switch is
 requested from an ISR is dependent on the port - see the documentation page
 for the port in use.

 \defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR
 \ingroup TaskNotifications
```*/
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );

 uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );
 @endcode

 Waits for a direct to task notification on a particular index in the calling
 task's notification array in a manner similar to taking a counting semaphore.

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
 function to be available.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 Events can be sent to a task using an intermediary object.  Examples of such
 objects are queues, semaphores, mutexes and event groups.  Task notifications
 are a method of sending an event directly to a task without the need for such
 an intermediary object.

 A notification sent to a task can optionally perform an action, such as
 update, overwrite or increment one of the task's notification values.  In
 that way task notifications can be used to send data to a task, or be used as
 light weight and fast binary or counting semaphores.

 ulTaskNotifyTakeIndexed() is intended for use when a task notification is
 used as a faster and lighter weight binary or counting semaphore alternative.
 Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,
 the equivalent action that instead uses a task notification is
 ulTaskNotifyTakeIndexed().

 When a task is using its notification value as a binary or counting semaphore
 other tasks should send notifications to it using the xTaskNotifyGiveIndexed()
 macro, or xTaskNotifyIndex() function with the eAction parameter set to
 eIncrement.

 ulTaskNotifyTakeIndexed() can either clear the task's notification value at
 the array index specified by the uxIndexToWaitOn parameter to zero on exit,
 in which case the notification value acts like a binary semaphore, or
 decrement the notification value on exit, in which case the notification
 value acts like a counting semaphore.

 A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for
 a notification.  The task does not consume any CPU time while it is in the
 Blocked state.

 Where as xTaskNotifyWaitIndexed() will return when a notification is pending,
 ulTaskNotifyTakeIndexed() will return when the task's notification value is
 not zero.

 **NOTE** Each notification within the array operates independently - a task
 can only block on one notification within the array at a time and will not be
 unblocked by a notification sent to any other array index.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  ulTaskNotifyTake() is the original API function, and remains backward
 compatible by always operating on the notification value at index 0 in the
 array. Calling ulTaskNotifyTake() is equivalent to calling
 ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.

 @param uxIndexToWaitOn The index within the calling task's array of
 notification values on which the calling task will wait for a notification to
 be non-zero.  uxIndexToWaitOn must be less than
 configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does
 not have this parameter and always waits for notifications on index 0.

 @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
 notification value is decremented when the function exits.  In this way the
 notification value acts like a counting semaphore.  If xClearCountOnExit is
 not pdFALSE then the task's notification value is cleared to zero when the
 function exits.  In this way the notification value acts like a binary
 semaphore.

 @param xTicksToWait The maximum amount of time that the task should wait in
 the Blocked state for the task's notification value to be greater than zero,
 should the count not already be greater than zero when
 ulTaskNotifyTake() was called.  The task will not consume any processing
 time while it is in the Blocked state.  This is specified in kernel ticks,
 the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time
 specified in milliseconds to a time specified in ticks.

 @return The task's notification count before it is either cleared to zero or
 decremented (see the xClearCountOnExit parameter).

 \defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed
 \ingroup TaskNotifications
```*/
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );

 BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
 @endcode

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 functions to be available.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 If a notification is sent to an index within the array of notifications then
 the notification at that index is said to be 'pending' until it is read or
 explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()
 is the function that clears a pending notification without reading the
 notification value.  The notification value at the same array index is not
 altered.  Set xTask to NULL to clear the notification state of the calling
 task.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  xTaskNotifyStateClear() is the original API function, and remains
 backward compatible by always operating on the notification value at index 0
 within the array. Calling xTaskNotifyStateClear() is equivalent to calling
 xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.

 @param xTask The handle of the RTOS task that will have a notification state
 cleared.  Set xTask to NULL to clear a notification state in the calling
 task.  To obtain a task's handle create the task using xTaskCreate() and
 make use of the pxCreatedTask parameter, or create the task using
 xTaskCreateStatic() and store the returned value, or use the task's name in
 a call to xTaskGetHandle().

 @param uxIndexToClear The index within the target task's array of
 notification values to act upon.  For example, setting uxIndexToClear to 1
 will clear the state of the notification at index 1 within the array.
 uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 ulTaskNotifyStateClear() does not have this parameter and always acts on the
 notification at index 0.

 @return pdTRUE if the task's notification state was set to
 eNotWaitingNotification, otherwise pdFALSE.

 \defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed
 \ingroup TaskNotifications
```*/
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task. h
 @code{c}
 uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );

 uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );
 @endcode

 See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.

 configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
 functions to be available.

 Each task has a private array of "notification values" (or 'notifications'),
 each of which is a 32-bit unsigned integer (uint32_t).  The constant
 configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
 array, and (for backward compatibility) defaults to 1 if left undefined.
 Prior to FreeRTOS V10.4.0 there was only one notification value per task.

 ulTaskNotifyValueClearIndexed() clears the bits specified by the
 ulBitsToClear bit mask in the notification value at array index uxIndexToClear
 of the task referenced by xTask.

 Backward compatibility information:
 Prior to FreeRTOS V10.4.0 each task had a single "notification value", and
 all task notification API functions operated on that value. Replacing the
 single notification value with an array of notification values necessitated a
 new set of API functions that could address specific notifications within the
 array.  ulTaskNotifyValueClear() is the original API function, and remains
 backward compatible by always operating on the notification value at index 0
 within the array. Calling ulTaskNotifyValueClear() is equivalent to calling
 ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.

 @param xTask The handle of the RTOS task that will have bits in one of its
 notification values cleared. Set xTask to NULL to clear bits in a
 notification value of the calling task.  To obtain a task's handle create the
 task using xTaskCreate() and make use of the pxCreatedTask parameter, or
 create the task using xTaskCreateStatic() and store the returned value, or
 use the task's name in a call to xTaskGetHandle().

 @param uxIndexToClear The index within the target task's array of
 notification values in which to clear the bits.  uxIndexToClear
 must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
 ulTaskNotifyValueClear() does not have this parameter and always clears bits
 in the notification value at index 0.

 @param ulBitsToClear Bit mask of the bits to clear in the notification value of
 xTask. Set a bit to 1 to clear the corresponding bits in the task's notification
 value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear
 the notification value to 0.  Set ulBitsToClear to 0 to query the task's
 notification value without clearing any bits.


 @return The value of the target task's notification value before the bits
 specified by ulBitsToClear were cleared.
 \defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear
 \ingroup TaskNotifications
```*/
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: u32,
    ) -> u32;
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );
 @endcode

 Capture the current time for future use with xTaskCheckForTimeOut().

 @param pxTimeOut Pointer to a timeout object into which the current time
 is to be captured.  The captured time includes the tick count and the number
 of times the tick count has overflowed since the system first booted.
 \defgroup vTaskSetTimeOutState vTaskSetTimeOutState
 \ingroup TaskCtrl
```*/
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );
 @endcode

 Determines if pxTicksToWait ticks has passed since a time was captured
 using a call to vTaskSetTimeOutState().  The captured time includes the tick
 count and the number of times the tick count has overflowed.

 @param pxTimeOut The time status as captured previously using
 vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated
 to reflect the current time status.
 @param pxTicksToWait The number of ticks to check for timeout i.e. if
 pxTicksToWait ticks have passed since pxTimeOut was last updated (either by
 vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.
 If the timeout has not occurred, pxTicksToWait is updated to reflect the
 number of remaining ticks.

 @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is
 returned and pxTicksToWait is updated to reflect the number of remaining
 ticks.

 @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html

 Example Usage:
 @code{c}
  // Driver library function used to receive uxWantedBytes from an Rx buffer
  // that is filled by a UART interrupt. If there are not enough bytes in the
  // Rx buffer then the task enters the Blocked state until it is notified that
  // more data has been placed into the buffer. If there is still not enough
  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()
  // is used to re-calculate the Block time to ensure the total amount of time
  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This
  // continues until either the buffer contains at least uxWantedBytes bytes,
  // or the total amount of time spent in the Blocked state reaches
  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are
  // available up to a maximum of uxWantedBytes.

  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )
  {
  size_t uxReceived = 0;
  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
  TimeOut_t xTimeOut;

      // Initialize xTimeOut.  This records the time at which this function
      // was entered.
      vTaskSetTimeOutState( &xTimeOut );

      // Loop until the buffer contains the wanted number of bytes, or a
      // timeout occurs.
      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )
      {
          // The buffer didn't contain enough data so this task is going to
          // enter the Blocked state. Adjusting xTicksToWait to account for
          // any time that has been spent in the Blocked state within this
          // function so far to ensure the total amount of time spent in the
          // Blocked state does not exceed MAX_TIME_TO_WAIT.
          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )
          {
              //Timed out before the wanted number of bytes were available,
              // exit the loop.
              break;
          }

          // Wait for a maximum of xTicksToWait ticks to be notified that the
          // receive interrupt has placed more data into the buffer.
          ulTaskNotifyTake( pdTRUE, xTicksToWait );
      }

      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.
      // The actual number of bytes read (which might be less than
      // uxWantedBytes) is returned.
      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,
                                                  pucBuffer,
                                                  uxWantedBytes );

      return uxReceived;
  }
 @endcode
 \defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut
 \ingroup TaskCtrl
```*/
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );
 @endcode

 This function corrects the tick count value after the application code has held
 interrupts disabled for an extended period resulting in tick interrupts having
 been missed.

 This function is similar to vTaskStepTick(), however, unlike
 vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a
 time at which a task should be removed from the blocked state.  That means
 tasks may have to be removed from the blocked state as the tick count is
 moved.

 @param xTicksToCatchUp The number of tick interrupts that have been missed due to
 interrupts being disabled.  Its value is not computed automatically, so must be
 computed by the application writer.

 @return pdTRUE if moving the tick count forward resulted in a task leaving the
 blocked state and a context switch being performed.  Otherwise pdFALSE.

 \defgroup xTaskCatchUpTicks xTaskCatchUpTicks
 \ingroup TaskCtrl
```*/
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 task.h
 @code{c}
 void vTaskResetState( void );
 @endcode

 This function resets the internal state of the task. It must be called by the
 application before restarting the scheduler.

 \defgroup vTaskResetState vTaskResetState
 \ingroup SchedulerControl
```*/
    pub fn vTaskResetState();
}
unsafe extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
unsafe extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskSwitchContext();
}
unsafe extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCore(xCoreID: BaseType_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskMissedYield();
}
unsafe extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
unsafe extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
/**
```text

 Type by which software timers are referenced.  For example, a call to
 xTimerCreate() returns an TimerHandle_t variable that can then be used to
 reference the subject timer in calls to other software timer API functions
 (for example, xTimerStart(), xTimerReset(), etc.).
```*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(xTimer: TimerHandle_t),
>;
pub type PendedFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32),
>;
unsafe extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const ::core::ffi::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    /**
```text

 void *pvTimerGetTimerID( TimerHandle_t xTimer );

 Returns the ID assigned to the timer.

 IDs are assigned to timers using the pvTimerID parameter of the call to
 xTimerCreated() that was used to create the timer, and by calling the
 vTimerSetTimerID() API function.

 If the same callback function is assigned to multiple timers then the timer
 ID can be used as time specific (timer local) storage.

 @param xTimer The timer being queried.

 @return The ID assigned to the timer being queried.

 Example usage:

 See the xTimerCreate() API function example usage scenario.
```*/
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    /**
```text

 void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );

 Sets the ID assigned to the timer.

 IDs are assigned to timers using the pvTimerID parameter of the call to
 xTimerCreated() that was used to create the timer.

 If the same callback function is assigned to multiple timers then the timer
 ID can be used as time specific (timer local) storage.

 @param xTimer The timer being updated.

 @param pvNewID The ID to assign to the timer.

 Example usage:

 See the xTimerCreate() API function example usage scenario.
```*/
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    /**
```text

 BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );

 Queries a timer to see if it is active or dormant.

 A timer will be dormant if:
     1) It has been created but not started, or
     2) It is an expired one-shot timer that has not been restarted.

 Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
 xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
 xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
 active state.

 @param xTimer The timer being queried.

 @return pdFALSE will be returned if the timer is dormant.  A value other than
 pdFALSE will be returned if the timer is active.

 Example usage:
 @verbatim
 // This function assumes xTimer has already been created.
 void vAFunction( TimerHandle_t xTimer )
 {
     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
     {
         // xTimer is active, do something.
     }
     else
     {
         // xTimer is not active, do something else.
     }
 }
 @endverbatim
```*/
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );

 Simply returns the handle of the timer service/daemon task.  It it not valid
 to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
```*/
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 const char * const pcTimerGetName( TimerHandle_t xTimer );

 Returns the name that was assigned to a timer when the timer was created.

 @param xTimer The handle of the timer being queried.

 @return The name assigned to the timer specified by the xTimer parameter.
```*/
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    /**
```text

 void vTimerSetReloadMode( TimerHandle_t xTimer, const BaseType_t xAutoReload );

 Updates a timer to be either an auto-reload timer, in which case the timer
 automatically resets itself each time it expires, or a one-shot timer, in
 which case the timer will only expire once unless it is manually restarted.

 @param xTimer The handle of the timer being updated.

 @param xAutoReload If xAutoReload is set to pdTRUE then the timer will
 expire repeatedly with a frequency set by the timer's period (see the
 xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If
 xAutoReload is set to pdFALSE then the timer will be a one-shot timer and
 enter the dormant state after it expires.
```*/
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, xAutoReload: BaseType_t);
}
unsafe extern "C" {
    /**
```text

 BaseType_t xTimerGetReloadMode( TimerHandle_t xTimer );

 Queries a timer to determine if it is an auto-reload timer, in which case the timer
 automatically resets itself each time it expires, or a one-shot timer, in
 which case the timer will only expire once unless it is manually restarted.

 @param xTimer The handle of the timer being queried.

 @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise
 pdFALSE is returned.
```*/
    pub fn xTimerGetReloadMode(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );

 Queries a timer to determine if it is an auto-reload timer, in which case the timer
 automatically resets itself each time it expires, or a one-shot timer, in
 which case the timer will only expire once unless it is manually restarted.

 @param xTimer The handle of the timer being queried.

 @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise
 pdFALSE is returned.
```*/
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 TickType_t xTimerGetPeriod( TimerHandle_t xTimer );

 Returns the period of a timer.

 @param xTimer The handle of the timer being queried.

 @return The period of the timer in ticks.
```*/
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    /**
```text

 TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );

 Returns the time in ticks at which the timer will expire.  If this is less
 than the current tick count then the expiry time has overflowed from the
 current time.

 @param xTimer The handle of the timer being queried.

 @return If the timer is running then the time in ticks at which the timer
 will next expire is returned.  If the timer is not running then the return
 value is undefined.
```*/
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromTask(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromISR(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTimerSetTimerNumber(xTimer: TimerHandle_t, uxTimerNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn uxTimerGetTimerNumber(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vTimerResetState();
}
/**
```text

 event_groups.h

 Type by which event groups are referenced.  For example, a call to
 xEventGroupCreate() returns an EventGroupHandle_t variable that can then
 be used as a parameter to other event group functions.

 \defgroup EventGroupHandle_t EventGroupHandle_t
 \ingroup EventGroup
```*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type EventBits_t = TickType_t;
unsafe extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  EventBits_t xEventGroupWaitBits(    EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToWaitFor,
                                      const BaseType_t xClearOnExit,
                                      const BaseType_t xWaitForAllBits,
                                      const TickType_t xTicksToWait );
 @endcode

 [Potentially] block to wait for one or more bits to be set within a
 previously created event group.

 This function cannot be called from an interrupt.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for xEventGroupWaitBits()
 to be available.

 @param xEventGroup The event group in which the bits are being tested.  The
 event group must have previously been created using a call to
 xEventGroupCreate().

 @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
 inside the event group.  For example, to wait for bit 0 and/or bit 2 set
 uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
 uxBitsToWaitFor to 0x07.  Etc.

 @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
 uxBitsToWaitFor that are set within the event group will be cleared before
 xEventGroupWaitBits() returns if the wait condition was met (if the function
 returns for a reason other than a timeout).  If xClearOnExit is set to
 pdFALSE then the bits set in the event group are not altered when the call to
 xEventGroupWaitBits() returns.

 @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
 xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
 are set or the specified block time expires.  If xWaitForAllBits is set to
 pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
 in uxBitsToWaitFor is set or the specified block time expires.  The block
 time is specified by the xTicksToWait parameter.

 @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
 for one/all (depending on the xWaitForAllBits value) of the bits specified by
 uxBitsToWaitFor to become set. A value of portMAX_DELAY can be used to block
 indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).

 @return The value of the event group at the time either the bits being waited
 for became set, or the block time expired.  Test the return value to know
 which bits were set.  If xEventGroupWaitBits() returned because its timeout
 expired then not all the bits being waited for will be set.  If
 xEventGroupWaitBits() returned because the bits it was waiting for were set
 then the returned value is the event group value before any bits were
 automatically cleared in the case that xClearOnExit parameter was set to
 pdTRUE.

 Example usage:
 @code{c}
 #define BIT_0 ( 1 << 0 )
 #define BIT_4 ( 1 << 4 )

 void aFunction( EventGroupHandle_t xEventGroup )
 {
 EventBits_t uxBits;
 const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;

      // Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
      // the event group.  Clear the bits before exiting.
      uxBits = xEventGroupWaitBits(
                  xEventGroup,    // The event group being tested.
                  BIT_0 | BIT_4,  // The bits within the event group to wait for.
                  pdTRUE,         // BIT_0 and BIT_4 should be cleared before returning.
                  pdFALSE,        // Don't wait for both bits, either bit will do.
                  xTicksToWait ); // Wait a maximum of 100ms for either bit to be set.

      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
      {
          // xEventGroupWaitBits() returned because both bits were set.
      }
      else if( ( uxBits & BIT_0 ) != 0 )
      {
          // xEventGroupWaitBits() returned because just BIT_0 was set.
      }
      else if( ( uxBits & BIT_4 ) != 0 )
      {
          // xEventGroupWaitBits() returned because just BIT_4 was set.
      }
      else
      {
          // xEventGroupWaitBits() returned because xTicksToWait ticks passed
          // without either BIT_0 or BIT_4 becoming set.
      }
 }
 @endcode
 \defgroup xEventGroupWaitBits xEventGroupWaitBits
 \ingroup EventGroup
```*/
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
 @endcode

 Clear bits within an event group.  This function cannot be called from an
 interrupt.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for xEventGroupClearBits()
 to be available.

 @param xEventGroup The event group in which the bits are to be cleared.

 @param uxBitsToClear A bitwise value that indicates the bit or bits to clear
 in the event group.  For example, to clear bit 3 only, set uxBitsToClear to
 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.

 @return The value of the event group before the specified bits were cleared.

 Example usage:
 @code{c}
 #define BIT_0 ( 1 << 0 )
 #define BIT_4 ( 1 << 4 )

 void aFunction( EventGroupHandle_t xEventGroup )
 {
 EventBits_t uxBits;

      // Clear bit 0 and bit 4 in xEventGroup.
      uxBits = xEventGroupClearBits(
                              xEventGroup,    // The event group being updated.
                              BIT_0 | BIT_4 );// The bits being cleared.

      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
      {
          // Both bit 0 and bit 4 were set before xEventGroupClearBits() was
          // called.  Both will now be clear (not set).
      }
      else if( ( uxBits & BIT_0 ) != 0 )
      {
          // Bit 0 was set before xEventGroupClearBits() was called.  It will
          // now be clear.
      }
      else if( ( uxBits & BIT_4 ) != 0 )
      {
          // Bit 4 was set before xEventGroupClearBits() was called.  It will
          // now be clear.
      }
      else
      {
          // Neither bit 0 nor bit 4 were set in the first place.
      }
 }
 @endcode
 \defgroup xEventGroupClearBits xEventGroupClearBits
 \ingroup EventGroup
```*/
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupClearBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
 @endcode

 Set bits within an event group.
 This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
 is a version that can be called from an interrupt.

 Setting bits in an event group will automatically unblock tasks that are
 blocked waiting for the bits.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for xEventGroupSetBits()
 to be available.

 @param xEventGroup The event group in which the bits are to be set.

 @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
 For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
 and bit 0 set uxBitsToSet to 0x09.

 @return The value of the event group at the time the call to
 xEventGroupSetBits() returns.  Returned value might have the bits specified
 by the uxBitsToSet parameter cleared if setting a bit results in a task
 that was waiting for the bit leaving the blocked state then it is possible
 the bit will be cleared automatically (see the xClearBitOnExit parameter
 of xEventGroupWaitBits()).

 Example usage:
 @code{c}
 #define BIT_0 ( 1 << 0 )
 #define BIT_4 ( 1 << 4 )

 void aFunction( EventGroupHandle_t xEventGroup )
 {
 EventBits_t uxBits;

      // Set bit 0 and bit 4 in xEventGroup.
      uxBits = xEventGroupSetBits(
                          xEventGroup,    // The event group being updated.
                          BIT_0 | BIT_4 );// The bits being set.

      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
      {
          // Both bit 0 and bit 4 remained set when the function returned.
      }
      else if( ( uxBits & BIT_0 ) != 0 )
      {
          // Bit 0 remained set when the function returned, but bit 4 was
          // cleared.  It might be that bit 4 was cleared automatically as a
          // task that was waiting for bit 4 was removed from the Blocked
          // state.
      }
      else if( ( uxBits & BIT_4 ) != 0 )
      {
          // Bit 4 remained set when the function returned, but bit 0 was
          // cleared.  It might be that bit 0 was cleared automatically as a
          // task that was waiting for bit 0 was removed from the Blocked
          // state.
      }
      else
      {
          // Neither bit 0 nor bit 4 remained set.  It might be that a task
          // was waiting for both of the bits to be set, and the bits were
          // cleared as the task left the Blocked state.
      }
 }
 @endcode
 \defgroup xEventGroupSetBits xEventGroupSetBits
 \ingroup EventGroup
```*/
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupSetBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToSet,
                                  const EventBits_t uxBitsToWaitFor,
                                  TickType_t xTicksToWait );
 @endcode

 Atomically set bits within an event group, then wait for a combination of
 bits to be set within the same event group.  This functionality is typically
 used to synchronise multiple tasks, where each task has to wait for the other
 tasks to reach a synchronisation point before proceeding.

 This function cannot be used from an interrupt.

 The function will return before its block time expires if the bits specified
 by the uxBitsToWait parameter are set, or become set within that time.  In
 this case all the bits specified by uxBitsToWait will be automatically
 cleared before the function returns.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for xEventGroupSync()
 to be available.

 @param xEventGroup The event group in which the bits are being tested.  The
 event group must have previously been created using a call to
 xEventGroupCreate().

 @param uxBitsToSet The bits to set in the event group before determining
 if, and possibly waiting for, all the bits specified by the uxBitsToWait
 parameter are set.

 @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
 inside the event group.  For example, to wait for bit 0 and bit 2 set
 uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set
 uxBitsToWaitFor to 0x07.  Etc.

 @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
 for all of the bits specified by uxBitsToWaitFor to become set.

 @return The value of the event group at the time either the bits being waited
 for became set, or the block time expired.  Test the return value to know
 which bits were set.  If xEventGroupSync() returned because its timeout
 expired then not all the bits being waited for will be set.  If
 xEventGroupSync() returned because all the bits it was waiting for were
 set then the returned value is the event group value before any bits were
 automatically cleared.

 Example usage:
 @code{c}
 // Bits used by the three tasks.
 #define TASK_0_BIT     ( 1 << 0 )
 #define TASK_1_BIT     ( 1 << 1 )
 #define TASK_2_BIT     ( 1 << 2 )

 #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )

 // Use an event group to synchronise three tasks.  It is assumed this event
 // group has already been created elsewhere.
 EventGroupHandle_t xEventBits;

 void vTask0( void *pvParameters )
 {
 EventBits_t uxReturn;
 TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;

   for( ;; )
   {
      // Perform task functionality here.

      // Set bit 0 in the event flag to note this task has reached the
      // sync point.  The other two tasks will set the other two bits defined
      // by ALL_SYNC_BITS.  All three tasks have reached the synchronisation
      // point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms
      // for this to happen.
      uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );

      if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )
      {
          // All three tasks reached the synchronisation point before the call
          // to xEventGroupSync() timed out.
      }
  }
 }

 void vTask1( void *pvParameters )
 {
   for( ;; )
   {
      // Perform task functionality here.

      // Set bit 1 in the event flag to note this task has reached the
      // synchronisation point.  The other two tasks will set the other two
      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the
      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait
      // indefinitely for this to happen.
      xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );

      // xEventGroupSync() was called with an indefinite block time, so
      // this task will only reach here if the synchronisation was made by all
      // three tasks, so there is no need to test the return value.
   }
 }

 void vTask2( void *pvParameters )
 {
   for( ;; )
   {
      // Perform task functionality here.

      // Set bit 2 in the event flag to note this task has reached the
      // synchronisation point.  The other two tasks will set the other two
      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the
      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait
      // indefinitely for this to happen.
      xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );

      // xEventGroupSync() was called with an indefinite block time, so
      // this task will only reach here if the synchronisation was made by all
      // three tasks, so there is no need to test the return value.
  }
 }

 @endcode
 \defgroup xEventGroupSync xEventGroupSync
 \ingroup EventGroup
```*/
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );
 @endcode

 A version of xEventGroupGetBits() that can be called from an ISR.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for xEventGroupGetBitsFromISR()
 to be available.

 @param xEventGroup The event group being queried.

 @return The event group bits at the time xEventGroupGetBitsFromISR() was called.

 \defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR
 \ingroup EventGroup
```*/
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
unsafe extern "C" {
    /**
```text

 event_groups.h
 @code{c}
  void xEventGroupDelete( EventGroupHandle_t xEventGroup );
 @endcode

 Delete an event group that was previously created by a call to
 xEventGroupCreate().  Tasks that are blocked on the event group will be
 unblocked and obtain 0 as the event group's value.

 The configUSE_EVENT_GROUPS configuration constant must be set to 1 for vEventGroupDelete()
 to be available.

 @param xEventGroup The event group being deleted.
```*/
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
unsafe extern "C" {
    pub fn vEventGroupSetBitsCallback(
        pvEventGroup: *mut ::core::ffi::c_void,
        ulBitsToSet: u32,
    );
}
unsafe extern "C" {
    pub fn vEventGroupClearBitsCallback(
        pvEventGroup: *mut ::core::ffi::c_void,
        ulBitsToClear: u32,
    );
}
unsafe extern "C" {
    pub fn uxEventGroupGetNumber(xEventGroup: *mut ::core::ffi::c_void) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vEventGroupSetNumber(
        xEventGroup: *mut ::core::ffi::c_void,
        uxEventGroupNumber: UBaseType_t,
    );
}
/**
```text

 Type by which queues are referenced.  For example, a call to xQueueCreate()
 returns an QueueHandle_t variable that can then be used as a parameter to
 xQueueSend(), xQueueReceive(), etc.
```*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
/**
```text

 Type by which queue sets are referenced.  For example, a call to
 xQueueCreateSet() returns an xQueueSet variable that can then be used as a
 parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
```*/
pub type QueueSetHandle_t = *mut QueueDefinition;
/**
```text

 Queue sets can contain both queues and semaphores, so the
 QueueSetMemberHandle_t is defined as a type to be used where a parameter or
 return value can be either an QueueHandle_t or an SemaphoreHandle_t.
```*/
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueueGenericSend(
                                  QueueHandle_t xQueue,
                                  const void * pvItemToQueue,
                                  TickType_t xTicksToWait
                                  BaseType_t xCopyPosition
                              );
 @endcode

 It is preferred that the macros xQueueSend(), xQueueSendToFront() and
 xQueueSendToBack() are used in place of calling this function directly.

 Post an item on a queue.  The item is queued by copy, not by reference.
 This function must not be called from an interrupt service routine.
 See xQueueSendFromISR () for an alternative which may be used in an ISR.

 @param xQueue The handle to the queue on which the item is to be posted.

 @param pvItemToQueue A pointer to the item that is to be placed on the
 queue.  The size of the items the queue will hold was defined when the
 queue was created, so this many bytes will be copied from pvItemToQueue
 into the queue storage area.

 @param xTicksToWait The maximum amount of time the task should block
 waiting for space to become available on the queue, should it already
 be full.  The call will return immediately if this is set to 0 and the
 queue is full.  The time is defined in tick periods so the constant
 portTICK_PERIOD_MS should be used to convert to real time if this is required.

 @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
 item at the back of the queue, or queueSEND_TO_FRONT to place the item
 at the front of the queue (for high priority messages).

 @return pdPASS if the item was successfully posted, otherwise errQUEUE_FULL.

 Example usage:
 @code{c}
 struct AMessage
 {
  char ucMessageID;
  char ucData[ 20 ];
 } xMessage;

 uint32_t ulVar = 10U;

 void vATask( void *pvParameters )
 {
 QueueHandle_t xQueue1, xQueue2;
 struct AMessage *pxMessage;

  // Create a queue capable of containing 10 uint32_t values.
  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );

  // Create a queue capable of containing 10 pointers to AMessage structures.
  // These should be passed by pointer as they contain a lot of data.
  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

  // ...

  if( xQueue1 != 0 )
  {
      // Send an uint32_t.  Wait for 10 ticks for space to become
      // available if necessary.
      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
      {
          // Failed to post the message, even after 10 ticks.
      }
  }

  if( xQueue2 != 0 )
  {
      // Send a pointer to a struct AMessage object.  Don't block if the
      // queue is already full.
      pxMessage = & xMessage;
      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
  }

  // ... Rest of task code.
 }
 @endcode
 \defgroup xQueueSend xQueueSend
 \ingroup QueueManagement
```*/
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueuePeek(
                           QueueHandle_t xQueue,
                           void * const pvBuffer,
                           TickType_t xTicksToWait
                       );
 @endcode

 Receive an item from a queue without removing the item from the queue.
 The item is received by copy so a buffer of adequate size must be
 provided.  The number of bytes copied into the buffer was defined when
 the queue was created.

 Successfully received items remain on the queue so will be returned again
 by the next call, or a call to xQueueReceive().

 This macro must not be used in an interrupt service routine.  See
 xQueuePeekFromISR() for an alternative that can be called from an interrupt
 service routine.

 @param xQueue The handle to the queue from which the item is to be
 received.

 @param pvBuffer Pointer to the buffer into which the received item will
 be copied.

 @param xTicksToWait The maximum amount of time the task should block
 waiting for an item to receive should the queue be empty at the time
 of the call. The time is defined in tick periods so the constant
 portTICK_PERIOD_MS should be used to convert to real time if this is required.
 xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
 is empty.

 @return pdPASS if an item was successfully received from the queue,
 otherwise errQUEUE_EMPTY.

 Example usage:
 @code{c}
 struct AMessage
 {
  char ucMessageID;
  char ucData[ 20 ];
 } xMessage;

 QueueHandle_t xQueue;

 // Task to create a queue and post a value.
 void vATask( void *pvParameters )
 {
 struct AMessage *pxMessage;

  // Create a queue capable of containing 10 pointers to AMessage structures.
  // These should be passed by pointer as they contain a lot of data.
  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
  if( xQueue == 0 )
  {
      // Failed to create the queue.
  }

  // ...

  // Send a pointer to a struct AMessage object.  Don't block if the
  // queue is already full.
  pxMessage = & xMessage;
  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );

  // ... Rest of task code.
 }

 // Task to peek the data from the queue.
 void vADifferentTask( void *pvParameters )
 {
 struct AMessage *pxRxedMessage;

  if( xQueue != 0 )
  {
      // Peek a message on the created queue.  Block for 10 ticks if a
      // message is not immediately available.
      if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
      {
          // pcRxedMessage now points to the struct AMessage variable posted
          // by vATask, but the item still remains on the queue.
      }
  }

  // ... Rest of task code.
 }
 @endcode
 \defgroup xQueuePeek xQueuePeek
 \ingroup QueueManagement
```*/
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueuePeekFromISR(
                                  QueueHandle_t xQueue,
                                  void *pvBuffer,
                              );
 @endcode

 A version of xQueuePeek() that can be called from an interrupt service
 routine (ISR).

 Receive an item from a queue without removing the item from the queue.
 The item is received by copy so a buffer of adequate size must be
 provided.  The number of bytes copied into the buffer was defined when
 the queue was created.

 Successfully received items remain on the queue so will be returned again
 by the next call, or a call to xQueueReceive().

 @param xQueue The handle to the queue from which the item is to be
 received.

 @param pvBuffer Pointer to the buffer into which the received item will
 be copied.

 @return pdPASS if an item was successfully received from the queue,
 otherwise pdFAIL.

 \defgroup xQueuePeekFromISR xQueuePeekFromISR
 \ingroup QueueManagement
```*/
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueueReceive(
                               QueueHandle_t xQueue,
                               void *pvBuffer,
                               TickType_t xTicksToWait
                          );
 @endcode

 Receive an item from a queue.  The item is received by copy so a buffer of
 adequate size must be provided.  The number of bytes copied into the buffer
 was defined when the queue was created.

 Successfully received items are removed from the queue.

 This function must not be used in an interrupt service routine.  See
 xQueueReceiveFromISR for an alternative that can.

 @param xQueue The handle to the queue from which the item is to be
 received.

 @param pvBuffer Pointer to the buffer into which the received item will
 be copied.

 @param xTicksToWait The maximum amount of time the task should block
 waiting for an item to receive should the queue be empty at the time
 of the call. xQueueReceive() will return immediately if xTicksToWait
 is zero and the queue is empty.  The time is defined in tick periods so the
 constant portTICK_PERIOD_MS should be used to convert to real time if this is
 required.

 @return pdPASS if an item was successfully received from the queue,
 otherwise errQUEUE_EMPTY.

 Example usage:
 @code{c}
 struct AMessage
 {
  char ucMessageID;
  char ucData[ 20 ];
 } xMessage;

 QueueHandle_t xQueue;

 // Task to create a queue and post a value.
 void vATask( void *pvParameters )
 {
 struct AMessage *pxMessage;

  // Create a queue capable of containing 10 pointers to AMessage structures.
  // These should be passed by pointer as they contain a lot of data.
  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
  if( xQueue == 0 )
  {
      // Failed to create the queue.
  }

  // ...

  // Send a pointer to a struct AMessage object.  Don't block if the
  // queue is already full.
  pxMessage = & xMessage;
  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );

  // ... Rest of task code.
 }

 // Task to receive from the queue.
 void vADifferentTask( void *pvParameters )
 {
 struct AMessage *pxRxedMessage;

  if( xQueue != 0 )
  {
      // Receive a message on the created queue.  Block for 10 ticks if a
      // message is not immediately available.
      if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
      {
          // pcRxedMessage now points to the struct AMessage variable posted
          // by vATask.
      }
  }

  // ... Rest of task code.
 }
 @endcode
 \defgroup xQueueReceive xQueueReceive
 \ingroup QueueManagement
```*/
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );
 @endcode

 Return the number of messages stored in a queue.

 @param xQueue A handle to the queue being queried.

 @return The number of messages available in the queue.

 \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
 \ingroup QueueManagement
```*/
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );
 @endcode

 Return the number of free spaces available in a queue.  This is equal to the
 number of items that can be sent to the queue before the queue becomes full
 if no items are removed.

 @param xQueue A handle to the queue being queried.

 @return The number of spaces available in the queue.

 \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
 \ingroup QueueManagement
```*/
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 void vQueueDelete( QueueHandle_t xQueue );
 @endcode

 Delete a queue - freeing all the memory allocated for storing of items
 placed on the queue.

 @param xQueue A handle to the queue to be deleted.

 \defgroup vQueueDelete vQueueDelete
 \ingroup QueueManagement
```*/
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueueGenericSendFromISR(
                                         QueueHandle_t    xQueue,
                                         const    void    *pvItemToQueue,
                                         BaseType_t  *pxHigherPriorityTaskWoken,
                                         BaseType_t  xCopyPosition
                                     );
 @endcode

 It is preferred that the macros xQueueSendFromISR(),
 xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
 of calling this function directly.  xQueueGiveFromISR() is an
 equivalent for use by semaphores that don't actually copy any data.

 Post an item on a queue.  It is safe to use this function from within an
 interrupt service routine.

 Items are queued by copy not reference so it is preferable to only
 queue small items, especially when called from an ISR.  In most cases
 it would be preferable to store a pointer to the item being queued.

 @param xQueue The handle to the queue on which the item is to be posted.

 @param pvItemToQueue A pointer to the item that is to be placed on the
 queue.  The size of the items the queue will hold was defined when the
 queue was created, so this many bytes will be copied from pvItemToQueue
 into the queue storage area.

 @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
 *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 to unblock, and the unblocked task has a priority higher than the currently
 running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
 a context switch should be requested before the interrupt is exited.

 @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
 item at the back of the queue, or queueSEND_TO_FRONT to place the item
 at the front of the queue (for high priority messages).

 @return pdPASS if the data was successfully sent to the queue, otherwise
 errQUEUE_FULL.

 Example usage for buffered IO (where the ISR can obtain more than one value
 per call):
 @code{c}
 void vBufferISR( void )
 {
 char cIn;
 BaseType_t xHigherPriorityTaskWokenByPost;

  // We have not woken a task at the start of the ISR.
  xHigherPriorityTaskWokenByPost = pdFALSE;

  // Loop until the buffer is empty.
  do
  {
      // Obtain a byte from the buffer.
      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );

      // Post each byte.
      xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );

  } while( portINPUT_BYTE( BUFFER_COUNT ) );

  // Now the buffer is empty we can switch context if necessary.
  if( xHigherPriorityTaskWokenByPost )
  {
       // As xHigherPriorityTaskWokenByPost is now set to pdTRUE then a context
       // switch should be requested. The macro used is port specific and
       // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
       // refer to the documentation page for the port being used.
       portYIELD_FROM_ISR( xHigherPriorityTaskWokenByPost );
  }
 }
 @endcode

 \defgroup xQueueSendFromISR xQueueSendFromISR
 \ingroup QueueManagement
```*/
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    /**
```text

 queue. h
 @code{c}
 BaseType_t xQueueReceiveFromISR(
                                     QueueHandle_t    xQueue,
                                     void             *pvBuffer,
                                     BaseType_t       *pxTaskWoken
                                 );
 @endcode

 Receive an item from a queue.  It is safe to use this function from within an
 interrupt service routine.

 @param xQueue The handle to the queue from which the item is to be
 received.

 @param pvBuffer Pointer to the buffer into which the received item will
 be copied.

 @param pxHigherPriorityTaskWoken A task may be blocked waiting for space to
 become available on the queue.  If xQueueReceiveFromISR causes such a task
 to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
 remain unchanged.

 @return pdPASS if an item was successfully received from the queue,
 otherwise pdFAIL.

 Example usage:
 @code{c}

 QueueHandle_t xQueue;

 // Function to create a queue and post some values.
 void vAFunction( void *pvParameters )
 {
 char cValueToPost;
 const TickType_t xTicksToWait = ( TickType_t )0xff;

  // Create a queue capable of containing 10 characters.
  xQueue = xQueueCreate( 10, sizeof( char ) );
  if( xQueue == 0 )
  {
      // Failed to create the queue.
  }

  // ...

  // Post some characters that will be used within an ISR.  If the queue
  // is full then this task will block for xTicksToWait ticks.
  cValueToPost = 'a';
  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
  cValueToPost = 'b';
  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );

  // ... keep posting characters ... this task may block when the queue
  // becomes full.

  cValueToPost = 'c';
  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
 }

 // ISR that outputs all the characters received on the queue.
 void vISR_Routine( void )
 {
 BaseType_t xTaskWokenByReceive = pdFALSE;
 char cRxedChar;

  while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
  {
      // A character was received.  Output the character now.
      vOutputCharacter( cRxedChar );

      // If removing the character from the queue woke the task that was
      // posting onto the queue xTaskWokenByReceive will have been set to
      // pdTRUE.  No matter how many times this loop iterates only one
      // task will be woken.
  }

  if( xTaskWokenByReceive != ( char ) pdFALSE;
  {
      taskYIELD ();
  }
 }
 @endcode
 \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
 \ingroup QueueManagement
```*/
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueSemaphoreTake(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xQueueTakeMutexRecursive(
        xMutex: QueueHandle_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vQueueAddToRegistry(
        xQueue: QueueHandle_t,
        pcQueueName: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    pub fn vQueueUnregisterQueue(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    pub fn pcQueueGetName(xQueue: QueueHandle_t) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
unsafe extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    pub fn xQueueSelectFromSetFromISR(
        xQueueSet: QueueSetHandle_t,
    ) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xQueueGenericReset(
        xQueue: QueueHandle_t,
        xNewQueue: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueItemSize(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueLength(xQueue: QueueHandle_t) -> UBaseType_t;
}
pub type SemaphoreHandle_t = QueueHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTaskGenericNotifyParams {
    pub xTaskToNotify: TaskHandle_t,
    pub uxIndexToNotify: UBaseType_t,
    pub ulValue: u32,
    pub eAction: eNotifyAction,
    pub pulPreviousNotificationValue: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xTaskGenericNotifyParams",
    ][::core::mem::size_of::<xTaskGenericNotifyParams>() - 32usize];
    [
        "Alignment of xTaskGenericNotifyParams",
    ][::core::mem::align_of::<xTaskGenericNotifyParams>() - 8usize];
    [
        "Offset of field: xTaskGenericNotifyParams::xTaskToNotify",
    ][::core::mem::offset_of!(xTaskGenericNotifyParams, xTaskToNotify) - 0usize];
    [
        "Offset of field: xTaskGenericNotifyParams::uxIndexToNotify",
    ][::core::mem::offset_of!(xTaskGenericNotifyParams, uxIndexToNotify) - 8usize];
    [
        "Offset of field: xTaskGenericNotifyParams::ulValue",
    ][::core::mem::offset_of!(xTaskGenericNotifyParams, ulValue) - 16usize];
    [
        "Offset of field: xTaskGenericNotifyParams::eAction",
    ][::core::mem::offset_of!(xTaskGenericNotifyParams, eAction) - 20usize];
    [
        "Offset of field: xTaskGenericNotifyParams::pulPreviousNotificationValue",
    ][::core::mem::offset_of!(xTaskGenericNotifyParams, pulPreviousNotificationValue)
        - 24usize];
};
pub type xTaskGenericNotifyParams_t = xTaskGenericNotifyParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTaskGenericNotifyWaitParams {
    pub uxIndexToWaitOn: UBaseType_t,
    pub ulBitsToClearOnEntry: u32,
    pub ulBitsToClearOnExit: u32,
    pub pulNotificationValue: *mut u32,
    pub xTicksToWait: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xTaskGenericNotifyWaitParams",
    ][::core::mem::size_of::<xTaskGenericNotifyWaitParams>() - 32usize];
    [
        "Alignment of xTaskGenericNotifyWaitParams",
    ][::core::mem::align_of::<xTaskGenericNotifyWaitParams>() - 8usize];
    [
        "Offset of field: xTaskGenericNotifyWaitParams::uxIndexToWaitOn",
    ][::core::mem::offset_of!(xTaskGenericNotifyWaitParams, uxIndexToWaitOn) - 0usize];
    [
        "Offset of field: xTaskGenericNotifyWaitParams::ulBitsToClearOnEntry",
    ][::core::mem::offset_of!(xTaskGenericNotifyWaitParams, ulBitsToClearOnEntry)
        - 8usize];
    [
        "Offset of field: xTaskGenericNotifyWaitParams::ulBitsToClearOnExit",
    ][::core::mem::offset_of!(xTaskGenericNotifyWaitParams, ulBitsToClearOnExit)
        - 12usize];
    [
        "Offset of field: xTaskGenericNotifyWaitParams::pulNotificationValue",
    ][::core::mem::offset_of!(xTaskGenericNotifyWaitParams, pulNotificationValue)
        - 16usize];
    [
        "Offset of field: xTaskGenericNotifyWaitParams::xTicksToWait",
    ][::core::mem::offset_of!(xTaskGenericNotifyWaitParams, xTicksToWait) - 24usize];
};
pub type xTaskGenericNotifyWaitParams_t = xTaskGenericNotifyWaitParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTimerGenericCommandFromTaskParams {
    pub xTimer: TimerHandle_t,
    pub xCommandID: BaseType_t,
    pub xOptionalValue: TickType_t,
    pub pxHigherPriorityTaskWoken: *mut BaseType_t,
    pub xTicksToWait: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xTimerGenericCommandFromTaskParams",
    ][::core::mem::size_of::<xTimerGenericCommandFromTaskParams>() - 40usize];
    [
        "Alignment of xTimerGenericCommandFromTaskParams",
    ][::core::mem::align_of::<xTimerGenericCommandFromTaskParams>() - 8usize];
    [
        "Offset of field: xTimerGenericCommandFromTaskParams::xTimer",
    ][::core::mem::offset_of!(xTimerGenericCommandFromTaskParams, xTimer) - 0usize];
    [
        "Offset of field: xTimerGenericCommandFromTaskParams::xCommandID",
    ][::core::mem::offset_of!(xTimerGenericCommandFromTaskParams, xCommandID) - 8usize];
    [
        "Offset of field: xTimerGenericCommandFromTaskParams::xOptionalValue",
    ][::core::mem::offset_of!(xTimerGenericCommandFromTaskParams, xOptionalValue)
        - 16usize];
    [
        "Offset of field: xTimerGenericCommandFromTaskParams::pxHigherPriorityTaskWoken",
    ][::core::mem::offset_of!(
        xTimerGenericCommandFromTaskParams, pxHigherPriorityTaskWoken
    ) - 24usize];
    [
        "Offset of field: xTimerGenericCommandFromTaskParams::xTicksToWait",
    ][::core::mem::offset_of!(xTimerGenericCommandFromTaskParams, xTicksToWait)
        - 32usize];
};
pub type xTimerGenericCommandFromTaskParams_t = xTimerGenericCommandFromTaskParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xEventGroupWaitBitsParams {
    pub xEventGroup: EventGroupHandle_t,
    pub uxBitsToWaitFor: EventBits_t,
    pub xClearOnExit: BaseType_t,
    pub xWaitForAllBits: BaseType_t,
    pub xTicksToWait: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of xEventGroupWaitBitsParams",
    ][::core::mem::size_of::<xEventGroupWaitBitsParams>() - 40usize];
    [
        "Alignment of xEventGroupWaitBitsParams",
    ][::core::mem::align_of::<xEventGroupWaitBitsParams>() - 8usize];
    [
        "Offset of field: xEventGroupWaitBitsParams::xEventGroup",
    ][::core::mem::offset_of!(xEventGroupWaitBitsParams, xEventGroup) - 0usize];
    [
        "Offset of field: xEventGroupWaitBitsParams::uxBitsToWaitFor",
    ][::core::mem::offset_of!(xEventGroupWaitBitsParams, uxBitsToWaitFor) - 8usize];
    [
        "Offset of field: xEventGroupWaitBitsParams::xClearOnExit",
    ][::core::mem::offset_of!(xEventGroupWaitBitsParams, xClearOnExit) - 16usize];
    [
        "Offset of field: xEventGroupWaitBitsParams::xWaitForAllBits",
    ][::core::mem::offset_of!(xEventGroupWaitBitsParams, xWaitForAllBits) - 24usize];
    [
        "Offset of field: xEventGroupWaitBitsParams::xTicksToWait",
    ][::core::mem::offset_of!(xEventGroupWaitBitsParams, xTicksToWait) - 32usize];
};
pub type xEventGroupWaitBitsParams_t = xEventGroupWaitBitsParams;
unsafe extern "C" {
    pub fn MPU_vTaskDelay(xTicksToDelay: TickType_t);
}
unsafe extern "C" {
    pub fn MPU_xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
unsafe extern "C" {
    pub fn MPU_vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
unsafe extern "C" {
    pub fn MPU_vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
unsafe extern "C" {
    pub fn MPU_vTaskResume(xTaskToResume: TaskHandle_t);
}
unsafe extern "C" {
    pub fn MPU_xTaskGetTickCount() -> TickType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskGetNumberOfTasks() -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> StackType_t;
}
unsafe extern "C" {
    pub fn MPU_vTaskSetApplicationTaskTag(
        xTask: TaskHandle_t,
        pxHookFunction: TaskHookFunction_t,
    );
}
unsafe extern "C" {
    pub fn MPU_xTaskGetApplicationTaskTag(xTask: TaskHandle_t) -> TaskHookFunction_t;
}
unsafe extern "C" {
    pub fn MPU_vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn MPU_pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn MPU_xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGetRunTimeCounter(xTask: TaskHandle_t) -> u32;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGetRunTimePercent(xTask: TaskHandle_t) -> u32;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGetIdleRunTimeCounter() -> u32;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGetIdleRunTimePercent() -> u32;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotifyEntry(
        pxParams: *const xTaskGenericNotifyParams_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotifyWaitEntry(
        pxParams: *const xTaskGenericNotifyWaitParams_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: u32,
    ) -> u32;
}
unsafe extern "C" {
    pub fn MPU_vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
unsafe extern "C" {
    pub fn MPU_xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGetSchedulerState() -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::core::ffi::c_char,
        uxStackDepth: StackType_t,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskCreateStatic(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::core::ffi::c_char,
        uxStackDepth: StackType_t,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        puxStackBuffer: *mut StackType_t,
        pxTaskBuffer: *mut StaticTask_t,
    ) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_vTaskDelete(xTaskToDelete: TaskHandle_t);
}
unsafe extern "C" {
    pub fn MPU_vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
unsafe extern "C" {
    pub fn MPU_xTaskGetHandle(pcNameToQuery: *const ::core::ffi::c_char) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn MPU_xTaskCreateRestricted(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskCreateRestrictedStatic(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_vTaskAllocateMPURegions(
        xTaskToModify: TaskHandle_t,
        xRegions: *const MemoryRegion_t,
    );
}
unsafe extern "C" {
    pub fn MPU_xTaskGetStaticBuffers(
        xTask: TaskHandle_t,
        ppuxStackBuffer: *mut *mut StackType_t,
        ppxTaskBuffer: *mut *mut StaticTask_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskBasePriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTaskBasePriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGetApplicationTaskTagFromISR(
        xTask: TaskHandle_t,
    ) -> TaskHookFunction_t;
}
unsafe extern "C" {
    pub fn MPU_xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueSemaphoreTake(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueTakeMutexRecursive(
        xMutex: QueueHandle_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_vQueueAddToRegistry(
        xQueue: QueueHandle_t,
        pcName: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    pub fn MPU_vQueueUnregisterQueue(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    pub fn MPU_pcQueueGetName(xQueue: QueueHandle_t) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn MPU_xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    pub fn MPU_vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn MPU_uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
unsafe extern "C" {
    pub fn MPU_vQueueDelete(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericCreateStatic(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        pucQueueStorage: *mut u8,
        pxStaticQueue: *mut StaticQueue_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueCreateSetStatic(
        uxEventQueueLength: UBaseType_t,
        pucQueueStorage: *mut u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueSetHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericReset(
        xQueue: QueueHandle_t,
        xNewQueue: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericGetStaticBuffers(
        xQueue: QueueHandle_t,
        ppucQueueStorage: *mut *mut u8,
        ppxStaticQueue: *mut *mut StaticQueue_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xQueueSelectFromSetFromISR(
        xQueueSet: QueueSetHandle_t,
    ) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    pub fn MPU_pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn MPU_vTimerSetTimerID(
        xTimer: TimerHandle_t,
        pvNewID: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn MPU_xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGenericCommandFromTask(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGenericCommandFromTaskEntry(
        pxParams: *const xTimerGenericCommandFromTaskParams_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_pcTimerGetName(xTimer: TimerHandle_t) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn MPU_vTimerSetReloadMode(xTimer: TimerHandle_t, xAutoReload: BaseType_t);
}
unsafe extern "C" {
    pub fn MPU_xTimerGetReloadMode(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerCreate(
        pcTimerName: *const ::core::ffi::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerCreateStatic(
        pcTimerName: *const ::core::ffi::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
        pxTimerBuffer: *mut StaticTimer_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGetStaticBuffer(
        xTimer: TimerHandle_t,
        ppxTimerBuffer: *mut *mut StaticTimer_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xTimerGenericCommandFromISR(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupWaitBitsEntry(
        pxParams: *const xEventGroupWaitBitsParams_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_uxEventGroupGetNumber(
        xEventGroup: *mut ::core::ffi::c_void,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn MPU_vEventGroupSetNumber(
        xEventGroup: *mut ::core::ffi::c_void,
        uxEventGroupNumber: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn MPU_xEventGroupCreate() -> EventGroupHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupCreateStatic(
        pxEventGroupBuffer: *mut StaticEventGroup_t,
    ) -> EventGroupHandle_t;
}
unsafe extern "C" {
    pub fn MPU_vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
unsafe extern "C" {
    pub fn MPU_xEventGroupGetStaticBuffer(
        xEventGroup: EventGroupHandle_t,
        ppxEventGroupBuffer: *mut *mut StaticEventGroup_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupClearBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupSetBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferSend(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferReceive(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferIsFull(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferIsEmpty(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferSpacesAvailable(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferBytesAvailable(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferSetTriggerLevel(
        xStreamBuffer: StreamBufferHandle_t,
        xTriggerLevel: usize,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferNextMessageLengthBytes(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferGenericCreate(
        xBufferSizeBytes: usize,
        xTriggerLevelBytes: usize,
        xStreamBufferType: BaseType_t,
        pxSendCompletedCallback: StreamBufferCallbackFunction_t,
        pxReceiveCompletedCallback: StreamBufferCallbackFunction_t,
    ) -> StreamBufferHandle_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferGenericCreateStatic(
        xBufferSizeBytes: usize,
        xTriggerLevelBytes: usize,
        xStreamBufferType: BaseType_t,
        pucStreamBufferStorageArea: *mut u8,
        pxStaticStreamBuffer: *mut StaticStreamBuffer_t,
        pxSendCompletedCallback: StreamBufferCallbackFunction_t,
        pxReceiveCompletedCallback: StreamBufferCallbackFunction_t,
    ) -> StreamBufferHandle_t;
}
unsafe extern "C" {
    pub fn MPU_vStreamBufferDelete(xStreamBuffer: StreamBufferHandle_t);
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferReset(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferGetStaticBuffers(
        xStreamBuffers: StreamBufferHandle_t,
        ppucStreamBufferStorageArea: *mut u8,
        ppxStaticStreamBuffer: *mut StaticStreamBuffer_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferSendFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferReceiveFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferSendCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferReceiveCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn MPU_xStreamBufferResetFromISR(
        xStreamBuffer: StreamBufferHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_pdFALSE() -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_pdTRUE() -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_configASSERT(value: ::core::ffi::c_int);
}
unsafe extern "C" {
    pub fn shim_pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn shim_portTICK_PERIOD_MS() -> TickType_t;
}
unsafe extern "C" {
    pub fn shim_portMAX_DELAY() -> TickType_t;
}
unsafe extern "C" {
    pub fn shim_taskYIELD();
}
unsafe extern "C" {
    pub fn shim_xQueueSendToBackFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xQueueSendToBack(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xQueueCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn shim_xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTaskNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTaskNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_ulTaskNotifyTake(
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
unsafe extern "C" {
    pub fn shim_xTimerStart(xTimer: TimerHandle_t, xBlockTime: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTimerStartFromISR(
        xTimer: TimerHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTimerStop(xTimer: TimerHandle_t, xBlockTime: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTimerChangePeriod(
        xTimer: TimerHandle_t,
        xNewPeriod: TickType_t,
        xBlockTime: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn shim_xTimerDelete(
        xTimer: TimerHandle_t,
        xBlockTime: TickType_t,
    ) -> BaseType_t;
}
